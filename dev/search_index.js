var documenterSearchIndex = {"docs":
[{"location":"ideal/#Ideal-objects","page":"Ideal objects","title":"Ideal objects","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"ideal/#Primitive-solids","page":"Ideal objects","title":"Primitive solids","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"ConstructiveGeometry.square\nConstructiveGeometry.circle\nConstructiveGeometry.cube\nConstructiveGeometry.cone\nConstructiveGeometry.cylinder\nConstructiveGeometry.sphere\nConstructiveGeometry.polygon\nConstructiveGeometry.surface","category":"page"},{"location":"ideal/#ConstructiveGeometry.square","page":"Ideal objects","title":"ConstructiveGeometry.square","text":"square(size; origin, center=false)\n\nAn axis-parallel square or rectangle  with given size (scalar or vector of length 2).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.cone","page":"Ideal objects","title":"ConstructiveGeometry.cone","text":"cone(h, r)\ncone(apex, r)\n\nCircular cone.\n\n\n\n\n\ncone(h, shape)\ncone(h)*shape\ncone(apex, shape)\ncone(apex)*shape\n\nCone with arbitrary base.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.cylinder","page":"Ideal objects","title":"ConstructiveGeometry.cylinder","text":"cylinder(h, r1, r2 [, center=false])\ncylinder(h, (r1, r2) [, center=false])\ncylinder(h, r [, center=false])\n\nWarning: cylinder(h,r) is interpreted as cylinder(h,r,r), not (h,r,0) as in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.polygon","page":"Ideal objects","title":"ConstructiveGeometry.polygon","text":"polygon(path)\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Transformations","page":"Ideal objects","title":"Transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"All transformations accept two possible syntaxes:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform(parameters, solid1, solid2, ...)\n    transform(parameters) * solid1","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"The second, multiplicative form allows easy chaining of transformations:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform1(param1) * transform2(param2) * solid","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"This form may also be applied to several solids by either wrapping them in a union, or equivalently, by applying it to a Vector of ConstructiveGeometry:","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"    transform(parameters) * [ solid1, solid2, ... ]","category":"page"},{"location":"ideal/#Affine-transformations","page":"Ideal objects","title":"Affine transformations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"ConstructiveGeometry.mult_matrix\nConstructiveGeometry.translate\nConstructiveGeometry.scale\nConstructiveGeometry.rotate\nConstructiveGeometry.mirror","category":"page"},{"location":"ideal/#ConstructiveGeometry.mult_matrix","page":"Ideal objects","title":"ConstructiveGeometry.mult_matrix","text":"mult_matrix(a, [center=c], solid...)\nmult_matrix(a, b, solid...)\nmult_matrix(a, b) * solid\n\nRepresents the affine operation x -> a*x + b.\n\nExtended help\n\nnote: Types of `mult_matrix` parameters\nThe precise type of parameters a and b is not specified. Usually, a will be a matrix and b a vector, but this is left open on purpose; for instance, a can be a scalar (for a scaling). Any types so that a * Vector + b is defined will be accepted.Conversion to a matrix will be done when converting to OpenSCAD format.\n\nnote: Matrix multiplication\nChained mult_matrix operations will be combined into a single operation when possible. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.translate","page":"Ideal objects","title":"ConstructiveGeometry.translate","text":"translate(v, s...)\ntranslate(v) * s\n\nTranslates solids s... by vector v.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.scale","page":"Ideal objects","title":"ConstructiveGeometry.scale","text":"scale(a, s...; center=0)\nscale(a; center=0) * s\n\nScales solids s by factor a. If center is given then this will be the invariant point.\n\na may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.rotate","page":"Ideal objects","title":"ConstructiveGeometry.rotate","text":"rotate(θ, {center=center}, {solid...})\nrotate(θ, axis=axis, {center=center}, {solid...})\n\nRotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).\n\n\n\n\n\nrotate((θ,φ,ψ), {center=center}, {solid...})\n\nRotation given by Euler angles (ZYX; same ordering as OpenSCAD).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.mirror","page":"Ideal objects","title":"ConstructiveGeometry.mirror","text":"mirror(v, s...; center=0)\nmirror(v; center=0) * s\n\nReflection with axis given by the hyperplane normal to v. If center is given, then the affine hyperplane through this point will be used.\n\n\n\n\n\n","category":"function"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"TODO: ConstructiveGeometry.project, ConstructiveGeometry.cut.","category":"page"},{"location":"ideal/#d-drawing","page":"Ideal objects","title":"2d drawing","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"ConstructiveGeometry.offset\nConstructiveGeometry.draw","category":"page"},{"location":"ideal/#ConstructiveGeometry.offset","page":"Ideal objects","title":"ConstructiveGeometry.offset","text":"offset(r, solid...; kwargs...)\noffset(r; kwargs...) * solid\n\nOffsets by given radius.\n\nends=:round|:square|:butt|:loop\njoin=:round|:miter|:square\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.draw","page":"Ideal objects","title":"ConstructiveGeometry.draw","text":"draw(path, width; kwargs)\nends = :loop|:butt|:square|:round\njoin = :square|:round|:miter\nmiter_limit = 2.0\n\nDraws a path of given width.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Extrusion","page":"Ideal objects","title":"Extrusion","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"ConstructiveGeometry.linear_extrude\nConstructiveGeometry.rotate_extrude\nConstructiveGeometry.path_extrude","category":"page"},{"location":"ideal/#ConstructiveGeometry.linear_extrude","page":"Ideal objects","title":"ConstructiveGeometry.linear_extrude","text":"linear_extrude(h, s...)\nlinear_extrude(h) * s...\n\nLinear extrusion to height h.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.rotate_extrude","page":"Ideal objects","title":"ConstructiveGeometry.rotate_extrude","text":"rotate_extrude([angle = 360°], solid...)\nrotate_extrude([angle = 360°]) * solid\n\nSimilar to OpenSCAD's rotate_extrude primitive.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#Inserting-metadata","page":"Ideal objects","title":"Inserting metadata","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as transform(parameters, s...) or as a product transform(parameters) * s.","category":"page"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"ConstructiveGeometry.color\nConstructiveGeometry.set_parameters","category":"page"},{"location":"ideal/#ConstructiveGeometry.color","page":"Ideal objects","title":"ConstructiveGeometry.color","text":"color(c::Colorant, s...)\ncolor(c::AbstractString, s...)\ncolor(c::AbstractString, α::Real, s...)\ncolor(c) * s...\n\nColors objects s... in the given color.\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.set_parameters","page":"Ideal objects","title":"ConstructiveGeometry.set_parameters","text":"set_parameters(;accuracy, precision, symmetry, ε, type) * solid...\n\nA transformation which passes down the specified parameter values to its child. Roughly similar to setting $fs and $fa in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"The set_parameters transformation allows attaching arbitrary metadata. This is on purpose (although there currently exists no easy way for an user to recover these metadata while meshing an object).","category":"page"},{"location":"ideal/#Defining-a-custom-transformation","page":"Ideal objects","title":"Defining a custom transformation","text":"","category":"section"},{"location":"ideal/#Operations","page":"Ideal objects","title":"Operations","text":"","category":"section"},{"location":"ideal/","page":"Ideal objects","title":"Ideal objects","text":"union(::AbstractGeometry,::AbstractGeometry)\nintersect(::AbstractGeometry,::AbstractGeometry)\nsetdiff(::AbstractGeometry,::AbstractGeometry)\nConstructiveGeometry.hull\nConstructiveGeometry.minkowski","category":"page"},{"location":"ideal/#ConstructiveGeometry.hull","page":"Ideal objects","title":"ConstructiveGeometry.hull","text":"hull(s::AbstractGeometry...)\n\thull(s::AbstractGeometry{2} | StaticVector{2}...)\n\nRepresents the convex hull of given solids (and, possibly, points).\n\n\n\n\n\n","category":"function"},{"location":"ideal/#ConstructiveGeometry.minkowski","page":"Ideal objects","title":"ConstructiveGeometry.minkowski","text":"minkowski(s::AbstractGeometry...)\n\nRepresents the Minkowski sum of given solids.\n\n\n\n\n\n","category":"function"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/#Interface","page":"Meshing","title":"Interface","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"mesh(object, parameters...)","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The meshing of objects is governed by a few parameters:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"accuracy and precision determine the number of faces inserted in the","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" mesh;","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"symmetry allows to impose a given rotational symmetry to circles;\ntype dictates the coordinate type of the returned mesh (e.g.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" `Float64` or `Rational{Int}`);","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"ε (experimental) is a value of thickness of planes, i.e. any point","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" closer than `ε` from a plane is considered as belonging to the plane.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"To set values other than the defaults for an object, apply the set_parameters transform to that object:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"set_parameters(accuracy=1)*\ncircle(2)","category":"page"},{"location":"meshing/#Accuracy-and-precision","page":"Meshing","title":"Accuracy and precision","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"accuracy is the maximum absolute deviation allowed when meshing an object.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is the maximum distance between the mesh and the ideal shape.  Its dimensionality is the same as basic length units for the object  (i.e. it will be understood as millimeters by most 3d slicers).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"precision is the maximum relative deviation allowed when meshing.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is a dimensionless number.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"When meshing an object, the minimum value will be used between those given by these two definitions. This means that precision gives an absolute maximum on the number of vertices for large objects, while accuracy governs ","category":"page"},{"location":"meshing/#Default-values","page":"Meshing","title":"Default values","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The default values are accuracy = 0.1 and precision = 1/200. The first value means that a circle will deviate by at most 0.1mm from the ideal circle, and  the latter value corresponds to the fact that large circles have 32 sides (see below).","category":"page"},{"location":"meshing/#Circles","page":"Meshing","title":"Circles","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"A circle of radius r is replaced by an inscribed n-gon. The deviation between the ideal circle and the n-gon is the sagitta of the circular segment with radius r and central angle 2πn; its value is hence s = r(1-cos(πn))  fracπ^2 r2 n^2.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"By definition, textttaccuracy = s while textttprecision = sr approx fracπ^22 n^2. This gives","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"n = min(π r(2textttaccuracy) π textttprecision))","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition, the number of sides is bounded below to always be at least 4. The number of sides thus increases as the square root of the radius, with an upper bound. With the default parameters, one has n  min(7r 32).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The corresponding value for OpenSCAD is n = min(2πrtexttttextdollar fs360texttttextdollar fa); with the default values texttttextdollar fa=12 and texttttextdollar fs=2, this gives n  min(π r 30).","category":"page"},{"location":"meshing/#Symmetry","page":"Meshing","title":"Symmetry","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition to accuracy and precision, the symmetry parameter allows forcing the number of vertices of a circle to be a multiple of a defined value (by rounding up, if needed, to a multiple of symmetry).","category":"page"},{"location":"meshing/#Mesh-type-for-2d-objects","page":"Meshing","title":"Mesh type for 2d objects","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"2d objects are represented as the exclusive union (XOR) of simple-loop polygons.","category":"page"},{"location":"meshing/#Mesh-type-for-3d-objects","page":"Meshing","title":"Mesh type for 3d objects","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"3d objects are represented as a triangulated mesh stored in a corner table. Since the mesh becomes (temporarily) non-manifold during computation of CSG operations, the structure actually implemented in this module is an extension of the basic corner table mesh, allowing representation of arbitrary non-manifold meshes. The details are inspired by Shin et al 2004.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The information stored in this structure is accessible via the following functions:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"points(m): returns a vector of points. The type used for points is a parameter of the CornerTable type. For objects built by ConstructiveGeometry.jl, this will be a SVector{3,<:Real}.\nfaces(m): returns a vector of faces, represented as NTUple{3,Int} of indices of points.","category":"page"},{"location":"#ConstructiveGeometry.jl-Documentation","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"warning: Warning\nThis package is very much a work-in-progress. Right now only very basic functionality is available (describing geometries, and some cases for meshing). Neither interface nor code are stable for now. Any contributions are welcome!","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"This package provides tools for describing 3d objects in Julia. This includes both geometry functions and a syntax describing constructive geometry. This syntax is inspired by OpenSCAD, but is actual Julia code:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"using ConstructiveGeometry\n\nsquare(20)\n\nlinear_extrude(30) * [\n  intersection(\n    translate([10,0]) * circle(3),\n    translate([13,0]) * circle(3),\n  ),\n  color(\"pink\") * scale(2) * square(1),\n]\n","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"The package is made of two parts:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"a system for describing geometric objects;\nback-ends for converting these objects to useful formats.","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"As of 2021-01, most object may either be:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"converted to OpenSCAD format, or\nexplicited as (2d or 3d) meshes.","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"Near-future plans include:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"graphical representation of objects using one of the Julia plotting packages;\ndirect export as a 2d (.svg) or 3d file (.stl or .ply).","category":"page"},{"location":"#Quick-start","page":"ConstructiveGeometry.jl Documentation","title":"Quick-start","text":"","category":"section"},{"location":"#Basic-example","page":"ConstructiveGeometry.jl Documentation","title":"Basic example","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"using ConstructiveGeometry\n\ns1 = union(\n  color(\"pink\")*\n  translate([3,0])*\n  scale([2,1])*\n  circle(3),\n\n  color(\"cyan\")*\n  translate([0,5])*\n  square([2,3])\n)\n\nmesh(s1)","category":"page"},{"location":"#I/O","page":"ConstructiveGeometry.jl Documentation","title":"I/O","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"ConstructiveGeometry.include\nConstructiveGeometry.scad","category":"page"},{"location":"#ConstructiveGeometry.include","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.include","text":"\tConstructiveGeometry.include(file::AbstractString, f::Function)\n\nReads given file and returns the union of all top-level Geometry objects (except the results of assignments) found in the file.\n\n#### Example: contents of file `example.jl`\nC=ConstructiveGeometry.cube(1)\nS=ConstructiveGeometry.square(1)\nConstructiveGeometry.circle(3)\nS\n\njulia> ConstructiveGeometry.include(\"example.jl\")\nunion() {\n circle(radius=3.0);\n square(size=[1.0, 1.0], center=false);\n}\n\n\n\n\n\n","category":"function"},{"location":"#ConstructiveGeometry.scad","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.scad","text":"scad(io::IO, name::Symbol, parameters, children)\nscad(filename::AbstractString, s::AbstractGeometry...)\nscad(io::IO, s::AbstractGeometry)\n\nReturns, in printable form (e.g. Symbol or String), the OpenSCAD name of this object.\n\n\n\n\n\n","category":"function"}]
}
