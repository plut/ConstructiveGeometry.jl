var documenterSearchIndex = {"docs":
[{"location":"transformations/#transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"All single-object transformations accept two possible syntaxes:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform(parameters, solid1, solid2, ...)\n    transform(parameters) * solid1","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The second, multiplicative form allows easy chaining of transformations:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform1(param1) * transform2(param2) * solid","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"This form may also be applied to several solids by either wrapping them in a union, or equivalently, by applying it to a Vector of such objects:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform(parameters) * [ solid1, solid2, ... ]","category":"page"},{"location":"transformations/#Affine-transformations","page":"Transformations","title":"Affine transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"mult_matrix","category":"page"},{"location":"transformations/#ConstructiveGeometry.mult_matrix","page":"Transformations","title":"ConstructiveGeometry.mult_matrix","text":"mult_matrix(a, [center=c], solid...)\nmult_matrix(a, b, solid...)\nmult_matrix(a, b) * solid\na * solid + b # preferred form\n\nRepresents the affine operation x -> a*x + b.\n\nExtended help\n\nnote: Types of `mult_matrix` parameters\nThe precise type of parameters a and b is not specified. Usually, a will be a matrix and b a vector, but this is left open on purpose; for instance, a can be a scalar (for a scaling). Any types so that a * Vector + b is defined will be accepted.Conversion to a matrix will be done when meshing.\n\nnote: Matrix multiplication\nChained affine transformations are composed before applying to the objects. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = mult_matrix([1 0 0;0 1 0;0 .5 1])*cube(10);\npng(\"mult_matrix1\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: a skewed cube)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Only invertible affine transformations are supported. Transformations with a negative determinant reverse the object (either reverse the polygon loops, or reverse the triangular faces of meshes) to preserve orientation.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"For non-invertible transformations, see project.","category":"page"},{"location":"transformations/#embed","page":"Transformations","title":"Three-dimensional embeddings of two-dimensional objects","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"As an exception, it is allowed to apply a (2d -> 3d) transformation to any three-dimensional object. The result of such a transformation is still two-dimensional (and will accordingly be rendered as a polygon), but the information about the embedding will be used when computing convex hull or Minkowski sum with a three-dimensional object.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = hull([30,0,0]+[1 0 0;0 1 0;.5 0 0]*circle(20), [0,0,30]);\npng(\"embed_2d_3d\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: convex hull of a non-canonically embedded circle and a point)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"translate","category":"page"},{"location":"transformations/#ConstructiveGeometry.translate","page":"Transformations","title":"ConstructiveGeometry.translate","text":"translate(v, s...)\ntranslate(v) * s\nv + s\n\nTranslates solids s... by vector v.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"scale","category":"page"},{"location":"transformations/#ConstructiveGeometry.scale","page":"Transformations","title":"ConstructiveGeometry.scale","text":"scale(a, s...; center=0)\nscale(a; center=0) * s\na * s\n\nScales solids s by factor a. If center is given then this will be the invariant point.\n\na may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = [1,1.5,2]*sphere(50);\npng(\"scaled_sphere\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: a diagonally scaled sphere produces an ellipsoid)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"rotate","category":"page"},{"location":"transformations/#ConstructiveGeometry.rotate","page":"Transformations","title":"ConstructiveGeometry.rotate","text":"rotate(θ, [center=center], [solid...])\nrotate(θ, axis=axis, [center=center], [solid...])\n\nRotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).\n\n\n\n\n\nrotate((θ,φ,ψ), [center=center], [solid...])\n\nRotation given by Euler angles (ZYX; same ordering as OpenSCAD).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Angles are in degrees by default. Angles in radians are supported through the use of Unitful.rad.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = rotate(30)*square(20);\npng(\"rotate\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: a rotated square)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"reflect","category":"page"},{"location":"transformations/#ConstructiveGeometry.reflect","page":"Transformations","title":"ConstructiveGeometry.reflect","text":"reflect(v, s...; center=0)\nreflect(v; center=0) * s\n\nReflection with axis given by the hyperplane normal to v. If center is given, then the affine hyperplane through this point will be used.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"raise\nlower","category":"page"},{"location":"transformations/#ConstructiveGeometry.raise","page":"Transformations","title":"ConstructiveGeometry.raise","text":"raise(z, s...)\n\nEquivalent to translate([0,0,z], s...).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#ConstructiveGeometry.lower","page":"Transformations","title":"ConstructiveGeometry.lower","text":"lower(z, s...)\n\nEquivalent to translate([0,0,-z], s...).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Overloaded-operators","page":"Transformations","title":"Overloaded operators","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The following operators are overloaded.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"matrix * solid is a linear transformation.\nvector * solid is a multiplication by a diagonal matrix.\nvector + solid is a translation.\nreal * solid is a scaling.\ncomplex * 2dshape is a similitude.\ncolor * solid is a color operation.\ncolor % solid is a highlight operation.","category":"page"},{"location":"transformations/#Two-dimensional-drawing","page":"Transformations","title":"Two-dimensional drawing","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"offset","category":"page"},{"location":"transformations/#ConstructiveGeometry.offset","page":"Transformations","title":"ConstructiveGeometry.offset","text":"offset(r, solid...; kwargs...)\noffset(r; kwargs...) * solid\n\nOffsets by given radius. Positive radius is outside the shape, negative radius is inside.\n\nParameters for 2d shapes:\n\nends=:round|:square|:butt|:loop\njoin=:round|:miter|:square\nmiter_limit=2.0\n\nParameter for 3d solids:\n\nmaxgrid = 32 # upper bound on the number of cubes used in one direction\n\nwarning: Complexity\nOffset of a volume is a costly operation; it is realized using a marching cubes algorithm on a grid defined by maxgrid. \tThus, its complexity is cubic in the parameter maxgrid.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The grid size used for offsetting is derived from the atol and rtol parameters, and upper bounded by the optional maxgrid parameter (if this is different from zero).","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s1 = offset(10)*[square(100,50), square(50,100)];\ns2 = offset(3)*cube(30);\npng(\"offset_L\", s1); # hide\npng(\"offset_cube\", s2); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: an offset L-shape) (Image: example: an offset cube)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"opening","category":"page"},{"location":"transformations/#ConstructiveGeometry.opening","page":"Transformations","title":"ConstructiveGeometry.opening","text":"opening(r, shape...; kwargs...)\n\nMorphological opening: offset(-r) followed by offset(r). Removes small appendages and rounds convex corners.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = opening(10)*[square(100,50), square(50,100)];\npng(\"opening\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: the opening of the L-shape)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"closing","category":"page"},{"location":"transformations/#ConstructiveGeometry.closing","page":"Transformations","title":"ConstructiveGeometry.closing","text":"closing(r, shape...; kwargs...)\n\nMorphological closing: offset(r) followed by offset(-r). Removes small holes and rounds concave corners.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = closing(10)*[square(100,50), square(50,100)];\npng(\"closing\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: the closing of the L-shape)","category":"page"},{"location":"transformations/#Extrusion","page":"Transformations","title":"Extrusion","text":"","category":"section"},{"location":"transformations/#Linear-extrusion","page":"Transformations","title":"Linear extrusion","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"linear_extrude","category":"page"},{"location":"transformations/#ConstructiveGeometry.linear_extrude","page":"Transformations","title":"ConstructiveGeometry.linear_extrude","text":"linear_extrude(h, s...; twist, scale)\nlinear_extrude(h) * s...\n\nLinear extrusion to height h.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s1 = linear_extrude(10)*[square(10,5), square(5,15)];\npng(\"linear_extrude\", s1); # hide\ns2 = linear_extrude(20, twist=45, scale=.8)*[square(10,5), square(5,15)];\npng(\"linear_extrude_twist\", s2); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: linear extrusion of a L-shape) (Image: example: linear extrusion with twist)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"rotate_extrude","category":"page"},{"location":"transformations/#ConstructiveGeometry.rotate_extrude","page":"Transformations","title":"ConstructiveGeometry.rotate_extrude","text":"rotate_extrude([angle = 360°], shape...; slide=0)\nrotate_extrude([angle = 360°]; [slide=0]) * shape\n\nSimilar to OpenSCAD's rotate_extrude primitive.\n\nThe slide parameter is a displacement along the z direction.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s1 = rotate_extrude(245)*[square(10,5), square(5,15)];\npng(\"rotate_extrude\", s1); # hide\ns2 = rotate_extrude(720, slide=30)*translate([10,0])*square(5);\npng(\"slide\", s2); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: rotation extrusion of a L-shape) (Image: example: rotational extrusion with slide)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The cone function may also be used as an operator to build a cone out of an arbitrary shape:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = cone([1,2,3])*square(5);\npng(\"cone_pyramid\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: using cone to build a pyramid)","category":"page"},{"location":"transformations/#Surface-sweep","page":"Transformations","title":"Surface sweep","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"sweep","category":"page"},{"location":"transformations/#ConstructiveGeometry.sweep","page":"Transformations","title":"ConstructiveGeometry.sweep","text":"sweep(path, shape...)\n\nExtrudes the given shape by\n\nrotating perpendicular to the path (rotating the unit y-vector\n\nto the direction z), and \n\nsweeping it along the path, with the origin on the path.\n\nFIXME: open-path extrusion is broken because ClipperLib currently does not support the etOpenSingle offset style.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"A swept surface is similar to a (closed) path extrusion:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = sweep(square(50))*circle(5);\npng(\"swept_circle\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: a circle swept along a square)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"warning: Swept surfaces\nA surface may only be swept along a closed loop (or the union of several closed loops) for now; this is a limitation of the clipper library, which does not support single-path extrusion for now (and this is unlikely to change in the near future).","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"f(t) =([ cospi(t) -sinpi(t) 0;sinpi(t) cospi(t) 0;0 0 1],[0 0 10*t]);\ns = sweep(f; nsteps=100,maxgrid=100)*cube(20);\npng(\"swept_cube\", s); # hide\n","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: a cube swept along a helix)","category":"page"},{"location":"transformations/#Decimation","page":"Transformations","title":"Decimation","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"These operations either reduce or increase the number of faces in a three-dimensional object.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"decimate","category":"page"},{"location":"transformations/#ConstructiveGeometry.decimate","page":"Transformations","title":"ConstructiveGeometry.decimate","text":"decimate(n, surface...)\n\nDecimates a 3d surface to at most n triangular faces.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"loop_subdivide","category":"page"},{"location":"transformations/#ConstructiveGeometry.loop_subdivide","page":"Transformations","title":"ConstructiveGeometry.loop_subdivide","text":"loop_subdivide(n, shape...)\n\nApplies n iterations of loop subdivision to the solid. This does not preserve shape; instead, it tends to “round out” the solid.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = loop_subdivide(4)*cube(20);\npng(\"loop_subdivide\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: loop subdivision of a cube)","category":"page"},{"location":"transformations/#Coloring-objects","page":"Transformations","title":"Coloring objects","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"color","category":"page"},{"location":"transformations/#ConstructiveGeometry.color","page":"Transformations","title":"ConstructiveGeometry.color","text":"color(c::Colorant, s...)\ncolor(c::AbstractString, s...)\ncolor(c::AbstractString, α::Real, s...)\ncolor(c) * s...\n\nColors objects s... in the given color.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"green, red = parse.(ConstructiveGeometry.Colorant, (\"green\", \"red\"))\ns = union(green * cube(10), [10,0,0]+red*sphere(10));\npng(\"color\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: union of a sphere and a cube)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"highlight","category":"page"},{"location":"transformations/#ConstructiveGeometry.highlight","page":"Transformations","title":"ConstructiveGeometry.highlight","text":"highlight(c::Colorant, s)\nhighlight(c::AbstractString, s)\n(c::Colorant) % s\n\nMarks an object as highlighted. This means that the base object will be displayed (in the specified color) at the same time as all results of operations built from this object.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = intersect(green % cube(10), red % ([10,0,0]+sphere(10)));\npng(\"highlight\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: intersection of a highlighted sphere and a highlighted cube)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Highlighted parts of objects are shown only when the object is represented as an image via the plot method (either interactively with GLMakie, or as an image with CairoMakie). For SVG and STL output, all highlighted parts are ignored.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"Highlighted objects are preserved only by CSG operations and (invertible) affine transformations. For other transformations:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"convex hull and Minkowski sum are generally increasing transformations, and would cover highlighted parts anyway;\nprojection, slicing and extrusion modify the dimension of object, making it impossible to preserve highlighted parts.","category":"page"},{"location":"transformations/#Modifying-meshing-parameters","page":"Transformations","title":"Modifying meshing parameters","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"set_parameters","category":"page"},{"location":"transformations/#ConstructiveGeometry.set_parameters","page":"Transformations","title":"ConstructiveGeometry.set_parameters","text":"set_parameters(;atol, rtol, symmetry) * solid...\n\nA transformation which passes down the specified parameter values to its child. Roughly similar to setting $fs and $fa in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The set_parameters transformation allows attaching arbitrary metadata. This is on purpose (although there currently exists no easy way for an user to recover these metadata while meshing an object).","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The values for these parameters are explained in atol and rtol.","category":"page"},{"location":"primitives/#primitives","page":"Primitive solids","title":"Primitive solids","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"ConstructiveGeometry.jl supports two basic families of objects: two-dimensional shapes and three-dimensional volumes.","category":"page"},{"location":"primitives/#Two-dimensional-shapes","page":"Primitive solids","title":"Two-dimensional shapes","text":"","category":"section"},{"location":"primitives/#Square","page":"Primitive solids","title":"Square","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"square","category":"page"},{"location":"primitives/#ConstructiveGeometry.square","page":"Primitive solids","title":"ConstructiveGeometry.square","text":"square(size; origin, center=false)\nsquare(width, height; origin, center=false)\n\nAn axis-parallel square or rectangle  with given size (scalar or vector of length 2).\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = square(20,15);\npng(\"square\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a square) square([20,15]) also works; square(20) produces a real square.","category":"page"},{"location":"primitives/#Circle","page":"Primitive solids","title":"Circle","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"circle","category":"page"},{"location":"primitives/#ConstructiveGeometry.circle","page":"Primitive solids","title":"ConstructiveGeometry.circle","text":"circle(r::Real, [circumscribed = false])\n\nA circle with diameter r, centered at the origin.\n\nThe corresponding mesh is a regular polygon, which is circumscribed to the ideal circle if circumscribed == true and inscribed otherwise.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = circle(20);\npng(\"circle\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a circle)","category":"page"},{"location":"primitives/#Stroke-path","page":"Primitive solids","title":"Stroke path","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"stroke","category":"page"},{"location":"primitives/#ConstructiveGeometry.stroke","page":"Primitive solids","title":"ConstructiveGeometry.stroke","text":"stroke(points, width; kwargs)\nends = :loop|:butt|:square|:round\njoin = :round|:square|:miter\nmiter_limit = 2.0\n\nDraws a path of given width.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = stroke([[0,0], [100,0],[100,100],[50,150],[0,100]],10);\ns1 = [120,0]+ stroke([[0,0], [100,0],[100,100],[50,150],[0,100]],10;ends=:loop,join=:square);\npng(\"stroke\", s ∪ s1); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a stroked path)","category":"page"},{"location":"primitives/#Polygon","page":"Primitive solids","title":"Polygon","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"polygon","category":"page"},{"location":"primitives/#ConstructiveGeometry.polygon","page":"Primitive solids","title":"ConstructiveGeometry.polygon","text":"polygon(path)\n\nFilled polygon delimitated by the given vertices.\n\nTODO: allow several paths and simplify crossing paths.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = polygon([[0,0], [100,0],[100,100],[50,150],[0,100]]);\npng(\"polygon\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a polygon)","category":"page"},{"location":"primitives/#Three-dimensional-volumes","page":"Primitive solids","title":"Three-dimensional volumes","text":"","category":"section"},{"location":"primitives/#Cube","page":"Primitive solids","title":"Cube","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cube","category":"page"},{"location":"primitives/#ConstructiveGeometry.cube","page":"Primitive solids","title":"ConstructiveGeometry.cube","text":"cube(size; origin, center=false)\ncube(size_x, size_y, size_z; origin, center=false)\n\nAn axis-parallel cube (or sett) with given size (scalar or vector of length 3).\n\nThe first vertex is at the origin and all vertices have positive coordinates. If center is true then the cube is centered.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cube(10,20,30);\npng(\"cube\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cube)","category":"page"},{"location":"primitives/#Cone","page":"Primitive solids","title":"Cone","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cone","category":"page"},{"location":"primitives/#ConstructiveGeometry.cone","page":"Primitive solids","title":"ConstructiveGeometry.cone","text":"cone(h, shape)\ncone(h)*shape\ncone(apex, shape)\ncone(apex)*shape\n\nCone with arbitrary base.\n\n\n\n\n\ncone(h, r; circumscribed=false)\n\nCircular right cone with basis centered at the origin, radius r, and height h. Equivalent to cone([0,0,h])*circle(r).\n\ncone(apex, r; circumscribed=false)\n\nCircular, possibly oblique, cone with given apex point and radius r around the origin.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cone(50,10);\npng(\"cone\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cone)","category":"page"},{"location":"primitives/#Cylinder","page":"Primitive solids","title":"Cylinder","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cylinder","category":"page"},{"location":"primitives/#ConstructiveGeometry.cylinder","page":"Primitive solids","title":"ConstructiveGeometry.cylinder","text":"cylinder(h, r , [center=false], [circumscribed=false])\ncylinder(h, r1, r2 , [center=false], [circumscribed=false])\n\nA cylinder (or cone frustum) with basis centered at the origin, lower radius r1, upper radius r2, and height h.\n\nWarning: cylinder(h,r) is interpreted as cylinder(h,r,r), not (h,r,0) as in OpenSCAD. For a cone, using (cone(h,r)) instead is recommended.\n\nThe mesh is a regular prism, circumscribed to the cylinder if circumscribed == true and inscribed otherwise.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cylinder(50,10);\npng(\"cylinder\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cylinder)","category":"page"},{"location":"primitives/#Sphere","page":"Primitive solids","title":"Sphere","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"sphere","category":"page"},{"location":"primitives/#ConstructiveGeometry.sphere","page":"Primitive solids","title":"ConstructiveGeometry.sphere","text":"sphere(r::Real, [circumscribed=false])\n\nA sphere with diameter r, centered at the origin.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = sphere(50);\npng(\"sphere\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a sphere)","category":"page"},{"location":"primitives/#Surface","page":"Primitive solids","title":"Surface","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"surface(::Any,::Any)","category":"page"},{"location":"primitives/#MakieCore.surface-Tuple{Any, Any}","page":"Primitive solids","title":"MakieCore.surface","text":"surface(vertices, faces)\n\nProduces a surface with the given vertices. faces is a list of n-uples of indices into vertices.\n\nNon-triangular faces are triangulated (by being first projected on the least-square fit plane).\n\n\n\n\n\n","category":"method"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = surface([[0,0,0],[10,0,0],[10,10,0],[0,10,0],[5,5,2]],\n  [(1,2,5),(2,3,5),(3,4,5),(4,1,5),(4,3,2,1)]);\npng(\"surface\",s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a pyramidal surface)","category":"page"},{"location":"meshing/#meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In the text terminal, objects are displayed as a CSG tree. To view them graphically, load a Makie back-end (e.g. use GLMakie) and call the Makie.plot command.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Objects are converted to explicit meshes for display or export as STL or SVG files.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The plot, stl, svg commands all perform implicit conversion to meshes; the package is useable without explicit call to the meshing functions. However, working with explicit meshes allows to e.g. perform arbitrary (non-linear) coordinate transformations on the objects.","category":"page"},{"location":"meshing/#Plotting","page":"Meshing","title":"Plotting","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This package defines methods for the Makie.plot function for all CSG objects. Volumes are represented as a triangulated mesh (with faces colored in the appropriate color); two-dimensional shapes are represented as filled polygons (colored in the default color).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"It is possible to display the objects either interactively with GLMakie, or as static images with CairoMakie; the latter is what is used to build the examples in this documentation.","category":"page"},{"location":"meshing/#Parameters","page":"Meshing","title":"Parameters","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The meshing of objects is governed by a few parameters:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"atol and rtol determine the number of faces inserted in the mesh;\nsymmetry allows to impose a given rotational symmetry to circles and cylinders.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"To set values other than the defaults for an object, apply the set_parameters transform to that object:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"set_parameters(atol=1)*\ncircle(2)","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"pwd()\ns = union(set_parameters(atol=1,symmetry=1)*circle(1),\n[2,0]+set_parameters(atol=1,symmetry=8)*circle(1),\n[4,0]+set_parameters(atol=1e-3)*circle(1));\npng(\"circles\", s); # hide","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"(Image: example: circles with various parameters)","category":"page"},{"location":"meshing/#Auxiliary-meshes","page":"Meshing","title":"Auxiliary meshes","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"These are the meshes of any highlight()ed parts of the objects. Auxiliary meshes are only used for displaying (whether interactively with GLMakie, or as an image with CairoMakie); they are ignored when exporting the object to STL or SVG format.","category":"page"},{"location":"meshing/#atol_rtol","page":"Meshing","title":"Precision: atol and rtol","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"atol is the maximum absolute deviation allowed when meshing an object.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is the maximum distance between the mesh and the ideal shape.  Its dimensionality is the same as basic length units for the object  (i.e. it will be understood as millimeters by most 3d slicers).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"rtol is the maximum relative deviation allowed when meshing.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is a dimensionless number.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"When meshing an object, the minimum value will be used between those given by these two definitions. This means that rtol gives an absolute maximum on the number of vertices for large objects, while atol governs the number of vertices for small objects.","category":"page"},{"location":"meshing/#Default-values","page":"Meshing","title":"Default values","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The default values are atol = 0.1 and rtol = 1/200. The first value means that a circle will deviate by at most 0.1mm from a perfect circle, and the latter value corresponds to the fact that large circles have 32 sides (see below).","category":"page"},{"location":"meshing/#Circles","page":"Meshing","title":"Circles","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"A circle of radius r is approximated by an inscribed n-gon. The deviation between the ideal circle and the n-gon is the sagitta of the circular segment with radius r and central angle 2πn; its value is hence s = r(1-cos(πn))  fracπ^2 r2 n^2.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"By definition, textttatol = s while textttrtol = sr approx fracπ^22 n^2. This gives","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"n = min(π r(2textttatol) π textttrtol))","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition, the number of sides is bounded below to always be at least 4. The number of sides thus increases as the square root of the radius, with an upper bound. With the default parameters, one has n  min(7r 32).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The corresponding value for OpenSCAD is n = min(2πrtexttttextdollar fs360texttttextdollar fa); with the default values texttttextdollar fa=12 and texttttextdollar fs=2, this gives n  min(π r 30).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"By default, circles are meshed as regular polygons inscribed in the circle. They can also be meshed as regular polygons circumscribed to that circle, by passing the circumscribed=true parameter:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"s = circle(1,circumscribed=true)\\circle(1);\npng(\"circumscribed\",s); # hide","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"(Image: difference of circumscribed and inscribed circles) The same parameter is also available for cylinders and spheres. The result is only approximated in the case of spheres, with the approximation being worse for small-radius spheres.","category":"page"},{"location":"meshing/#Spheres","page":"Meshing","title":"Spheres","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Spheres are rendered as Fibonacci spheres. This produces a more regular mesh than latitude-longitude grids (in particular, the grid does not have singularities at the poles).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"A sphere is approximated by an inscribed polyhedron with n vertices. Such a polyhedron has 2n-4 triangular faces; the average area of a face is frac4π r^22n-4 = frac2π r^2n-2, thus the average (squared) edge length is d²  (8π3) fracr^2n-2 (according to the unit equilateral triangle area 34).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The sagitta for a chord of length d is given by sr = 1 - 1-d^24r^2  (1-(1-d^28 r^2))  (π3)(n-2). Hence we find","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"n  2 + (π3)(textrmmax(textttrtoltextttatolr))","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"With the default values for atol and rtol:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"small spheres have approximately 2+18r vertices (and always at least 6 vertices);\nlarge spheres have 365 vertices.","category":"page"},{"location":"meshing/#Symmetry","page":"Meshing","title":"Symmetry","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition to atol and rtol, the symmetry parameter allows forcing the number of vertices of a circle to be a multiple of a defined value (by rounding up, if needed, to a multiple of symmetry).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This parameter currently has no effect on spheres (this is on the to-do list).","category":"page"},{"location":"meshing/#Mesh-types-and-orientation","page":"Meshing","title":"Mesh types and orientation","text":"","category":"section"},{"location":"meshing/#Two-dimensional-shapes","page":"Meshing","title":"Two-dimensional shapes","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Two-dimensional objects are represented as the exclusive union (XOR) of simple-loop polygons (using even-odd rule). Internally, direct loops (counter-clockwise) represent polygons, and retrograde loops (clockwise) represent holes.","category":"page"},{"location":"meshing/#Three-dimensional-volumes","page":"Meshing","title":"Three-dimensional volumes","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Three-dimensional objects are represented as a triangle mesh, in a way compatible with LibIGL's functions. The triangles are oriented so that their normal vector points outside the volume of the object.","category":"page"},{"location":"#[ConstructiveGeometry.jl](https://github.com/plut/ConstructiveGeometry.jl)-Documentation","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"This package provides tools for describing 3d objects in Julia. For example, this is the Julia code used to draw the logo of this page:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"using ConstructiveGeometry\nusing CairoMakie\n\nhexagon = polygon([[cospi(t/3),sinpi(t/3)] for t in 0:5])\nc1, c2, c3 = parse.(ConstructiveGeometry.Colorant, ( \"#cb3c33\", \"#9558b2\", \"#389826\"))\n\nbolt = linear_extrude(5)*(8*hexagon) ∪ cylinder(15,4) ∪\n\trotate_extrude(7*360, slide=14)*translate([1,0])*square(4,1)\n\nm = union(c1*bolt, [20,0,0]+c2*bolt, [10,17,0]+c3*bolt)\n\nsave(\"logo.png\", Makie.plot(m))","category":"page"},{"location":"#Overview","page":"ConstructiveGeometry.jl Documentation","title":"Overview","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"This package defines three kinds of abstract geometric objects (in either two or three dimensions):","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"primitive geometric objects, such as cubes, spheres, etc.;\ngeometric transformations acting on one object, such as (invertible) affine transformations, extrusions, projections, color-change, etc.;\nCSG operations combining several objects, such as boolean operations or Minkowski sum.","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"Any geometric object defined in this way can then be instantiated as an explicit mesh. The mesh may be visualized directly within Julia (using Makie) or exported as an STL (for 3d objects) or SVG (for 2d objects) file.","category":"page"},{"location":"io/#io","page":"Mesh I/O","title":"Mesh I/O","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Loading and saving of files can be done through the FileIO functions load and save.","category":"page"},{"location":"io/#File-loading","page":"Mesh I/O","title":"File loading","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Files can be loaded in this way:","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"using FileIO\nbust = load(\"beethoven.ply\")","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"The following formats should be supported: .stl (ASCII and binary) .ply (ASCII and little-endian/big-endian binary).","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"TODO: .dxf","category":"page"},{"location":"io/#File-saving","page":"Mesh I/O","title":"File saving","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Files can be saved in this way:","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"using FileIO\nsave(\"foo.stl\", object)","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"The following formats are supported: .stl (ASCII) and .ply (ASCII) for volumes; .svg for shapes.","category":"page"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Image file formats are also supported through CairoMakie's plot functions.","category":"page"},{"location":"io/#OpenSCAD-output","page":"Mesh I/O","title":"OpenSCAD output","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"ConstructiveGeometry.scad","category":"page"},{"location":"io/#ConstructiveGeometry.scad","page":"Mesh I/O","title":"ConstructiveGeometry.scad","text":"scad(io::IO, name::Symbol, parameters, children)\nscad(filename::AbstractString, s::AbstractGeometry...)\nscad(io::IO, s::AbstractGeometry)\n\nReturns, in printable form (e.g. Symbol or String), the OpenSCAD name of this object.\n\n\n\n\n\n","category":"function"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"warning: Deprecated\nSince the constructions from this package have started to diverge from those of OpenSCAD, (and also since the possibilities for export and visualization have improved), OpenSCAD output is being deprecated and may be removed in a future version.","category":"page"},{"location":"io/#OpenSCAD-to-Julia-conversion.","page":"Mesh I/O","title":"OpenSCAD to Julia conversion.","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Might be possible for a limited subset of OpenSCAD language. TODO.","category":"page"},{"location":"operations/#operations","page":"CSG operations","title":"CSG operations","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"operations/#Boolean-operations","page":"CSG operations","title":"Boolean operations","text":"","category":"section"},{"location":"operations/#Basic-operations","page":"CSG operations","title":"Basic operations","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"union(::AbstractGeometry,::AbstractGeometry)","category":"page"},{"location":"operations/#Base.union-Tuple{ConstructiveGeometry.AbstractGeometry, ConstructiveGeometry.AbstractGeometry}","page":"CSG operations","title":"Base.union","text":"union(a::AbstractGeometry...)\n\nComputes the union of several solids. The dimensions must match.\n\n\n\n\n\n","category":"method"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = union(cube(50), sphere(50));\npng(\"union\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: union of a sphere and a cube)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"N-ary union may be performed in this way:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = union(([0,10i]+square(5) for i in 1:5)...);\npng(\"n-union\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: n-ary union)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"intersect(::AbstractGeometry{D},::AbstractGeometry{D}) where{D}","category":"page"},{"location":"operations/#Base.intersect-Union{Tuple{D}, Tuple{ConstructiveGeometry.AbstractGeometry{D}, ConstructiveGeometry.AbstractGeometry{D}}} where D","page":"CSG operations","title":"Base.intersect","text":"intersect(a::AbstractGeometry...)\n\nComputes the intersection of several solids. Mismatched dimensions are allowed; 3d solids will be intersected with the horizontal plane (as if by the slice() operation) and a 2d intersection will be returned.\n\n\n\n\n\n","category":"method"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = intersect(cube(50), sphere(50));\npng(\"intersection\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: intersection of a sphere and a cube)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"setdiff(::AbstractGeometry{D},::AbstractGeometry{D}) where{D}","category":"page"},{"location":"operations/#Base.setdiff-Union{Tuple{D}, Tuple{ConstructiveGeometry.AbstractGeometry{D}, ConstructiveGeometry.AbstractGeometry{D}}} where D","page":"CSG operations","title":"Base.setdiff","text":"setdiff(a::AbstractGeometry, b::AbstractGeometry)\n\nComputes the difference of two solids. The following dimensions are allowed: (2,2), (3,3), and (2,3). In the latter case, the 3d object will be intersected with the horizontal plane via the slice() operation.\n\n\n\n\n\n","category":"method"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = setdiff(cube(50), [50,0,0]+sphere(50));\npng(\"setdiff\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: difference of a sphere and a cube)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"complement","category":"page"},{"location":"operations/#ConstructiveGeometry.complement","page":"CSG operations","title":"ConstructiveGeometry.complement","text":"complement(x::AbstractGeometry)\n~x\n\nReturns the complement of x, i.e. an object X such that y ∩ X = y ∖ x.\n\nnote: Warning: complement\nComplements are symbolic and only supported as shortcuts for some Boolean operations: ∪, ∩, ∖. (They would not make any sense in most other constructions anyway).\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"Complements are provided as a shortcut to simplify “subtractive” operations, i.e. chains of intersections and differences. See Three-dimensional embeddings of two-dimensional objects.","category":"page"},{"location":"operations/#Rewriting-rules","page":"CSG operations","title":"Rewriting rules","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"The CSG tree as constructed by the user is subjected to immediate rewriting (this is performed by the union, intersect etc. functions), before any meshing function is called.","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"The following rewriting rules are used:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"associative operations (union, intersect, hull, minkowski) are regrouped:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"display(union(union(square(1), circle(1)), polygon([])))","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"single-operand unions and intersects are removed:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"display(union(square(1)))","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"symbolic complements are replaced by the appropriate values:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"display(intersect(square(1), ~circle(1), polygon([])))","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"empty unions and intersections are removed:","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"display(union(square(1),union(),circle(1)))","category":"page"},{"location":"operations/#Convex-hull","page":"CSG operations","title":"Convex hull","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"hull","category":"page"},{"location":"operations/#ConstructiveGeometry.hull","page":"CSG operations","title":"ConstructiveGeometry.hull","text":"hull(s::AbstractGeometry...)\nhull(s::AbstractGeometry | StaticVector...)\n\nRepresents the convex hull of given solids (and, possibly, individual points). Mixing dimensions (and points) is allowed.\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = hull(cube(50), [50,0,0]+sphere(50));\npng(\"hull\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: convex hull of a sphere and a cube)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"In the case of mixed dimensions, two-dimensional objects are understood as included in the horizontal plane, unless they have been subjected to a three-dimensional affine transformation; in that case, this transformation is applied to their vertices. See Three-dimensional embeddings of two-dimensional objects.","category":"page"},{"location":"operations/#Minkowski-sum","page":"CSG operations","title":"Minkowski sum","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"minkowski","category":"page"},{"location":"operations/#ConstructiveGeometry.minkowski","page":"CSG operations","title":"ConstructiveGeometry.minkowski","text":"minkowski(s1::AbstractGeometry, s2::AbstractGeometry)\n\nRepresents the Minkowski sum of given solids. Mixing dimensions is allowed (and returns a three-dimensional object).\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"c = cube(10);\ns1 = minkowski(square(50), circle(20));\ns2 = minkowski(c, cube(20,1,1));\ns3 = minkowski(c, polygon([[0,0],[0,30],[30,0]]));\npng(\"minkowski_square_circle\",s1); # hide\npng(\"minkowski_cube_cube\",s2); # hide\npng(\"minkowski_cube_polygon\", s3); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"The Minkowski sum between a polygon and a circle of radius r is the same as the offset of the polygon by this radius: (Image: example: Minkowski sum of a square and a circle)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"Minkowski sum between volumes is allowed; e.g. the Minkowski sum of two axis-aligned parallelepipeds is again a parallelepiped: (Image: example: Minkowski sum of two axis-aligned cubes)","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"Minkowski sum between a volume and a polygon is also allowed; here the polygon is a triangle in the horizontal plane: (Image: example: Minkowski sum of a cube and a polygon)","category":"page"},{"location":"operations/#Slicing-and-projection","page":"CSG operations","title":"Slicing and projection","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"Slicing and projection convert a volume to a shape. These transformations are only defined with respect to horizontal planes, since these are the only planes in which canonical (x,y) coordinates are defined.","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"To use another plane, say the image of the horizontal plane by a rotation R, apply the inverse rotation of R to the object to bring the situation back to the horizontal plane.","category":"page"},{"location":"operations/#slice","page":"CSG operations","title":"slice","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"slice","category":"page"},{"location":"operations/#ConstructiveGeometry.slice","page":"CSG operations","title":"ConstructiveGeometry.slice","text":"slice(z, s...)\nslice(s...)\n\nComputes the (3d to 2d) intersection of a shape and the given horizontal plane (at z=0 if not precised).\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = slice()*setdiff(sphere(20),sphere(18));\npng(\"slice\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: slicing a hollow sphere)","category":"page"},{"location":"operations/#project","page":"CSG operations","title":"project","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"project","category":"page"},{"location":"operations/#ConstructiveGeometry.project","page":"CSG operations","title":"ConstructiveGeometry.project","text":"project(s...)\n\nComputes the (3d to 2d) projection of a shape on the horizontal plane.\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = project()*setdiff(sphere(20),sphere(18));\npng(\"project\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: projecting a hollow sphere)","category":"page"},{"location":"operations/#Intersection-with-half-space","page":"CSG operations","title":"Intersection with half-space","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"half","category":"page"},{"location":"operations/#ConstructiveGeometry.half","page":"CSG operations","title":"ConstructiveGeometry.half","text":"half(direction, s...; origin = 0)\nhalf(direction; origin = 0) * s\n\nKeeps only the part of objects s lying in the halfspace/halfplane with given direction and origin.\n\ndirection may be either a vector, or one of the six symbols  :top, :bottom, :left, :right, :front, :back.\n\norigin may be either a point (i.e. one point on the hyperplane) or a scalar (b in the equation a*x=b of the hyperplane).\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"s = half(:bottom)*setdiff(sphere(20),sphere(18));\npng(\"halfspace\", s); # hide","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"(Image: example: one half of a hollow sphere)","category":"page"}]
}
