var documenterSearchIndex = {"docs":
[{"location":"transformations/#transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"All single-object transformations accept two possible syntaxes:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform(parameters, solid1, solid2, ...)\n    transform(parameters) * solid1","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The second, multiplicative form allows easy chaining of transformations:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform1(param1) * transform2(param2) * solid","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"This form may also be applied to several solids by either wrapping them in a union, or equivalently, by applying it to a Vector of ConstructiveGeometry:","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"    transform(parameters) * [ solid1, solid2, ... ]","category":"page"},{"location":"transformations/#Affine-transformations","page":"Transformations","title":"Affine transformations","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"mult_matrix","category":"page"},{"location":"transformations/#ConstructiveGeometry.mult_matrix","page":"Transformations","title":"ConstructiveGeometry.mult_matrix","text":"mult_matrix(a, [center=c], solid...)\nmult_matrix(a, b, solid...)\nmult_matrix(a, b) * solid\n\nRepresents the affine operation x -> a*x + b.\n\nExtended help\n\nnote: Types of `mult_matrix` parameters\nThe precise type of parameters a and b is not specified. Usually, a will be a matrix and b a vector, but this is left open on purpose; for instance, a can be a scalar (for a scaling). Any types so that a * Vector + b is defined will be accepted.Conversion to a matrix will be done when meshing.\n\nnote: Matrix multiplication\nChained mult_matrix operations will be combined into a single operation when possible. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = mult_matrix([1 0 0;0 1 0;0 .5 1])*cube(10);\npng(\"mult_matrix1\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: a skewed cube)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"translate","category":"page"},{"location":"transformations/#ConstructiveGeometry.translate","page":"Transformations","title":"ConstructiveGeometry.translate","text":"translate(v, s...)\ntranslate(v) * s\nv + s\n\nTranslates solids s... by vector v.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"scale","category":"page"},{"location":"transformations/#ConstructiveGeometry.scale","page":"Transformations","title":"ConstructiveGeometry.scale","text":"scale(a, s...; center=0)\nscale(a; center=0) * s\n\ta * s\n\nScales solids s by factor a. If center is given then this will be the invariant point.\n\na may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"rotate","category":"page"},{"location":"transformations/#ConstructiveGeometry.rotate","page":"Transformations","title":"ConstructiveGeometry.rotate","text":"rotate(θ, {center=center}, {solid...})\nrotate(θ, axis=axis, {center=center}, {solid...})\n\nRotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).\n\n\n\n\n\nrotate((θ,φ,ψ), {center=center}, {solid...})\n\nRotation given by Euler angles (ZYX; same ordering as OpenSCAD).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = rotate(30)*square(20)\npng(\"rotate\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: a rotated square)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"mirror","category":"page"},{"location":"transformations/#ConstructiveGeometry.mirror","page":"Transformations","title":"ConstructiveGeometry.mirror","text":"mirror(v, s...; center=0)\nmirror(v; center=0) * s\n\nReflection with axis given by the hyperplane normal to v. If center is given, then the affine hyperplane through this point will be used.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"raise\nlower","category":"page"},{"location":"transformations/#ConstructiveGeometry.raise","page":"Transformations","title":"ConstructiveGeometry.raise","text":"raise(z, s...)\n\nEquivalent to translate([0,0,z], s...).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#ConstructiveGeometry.lower","page":"Transformations","title":"ConstructiveGeometry.lower","text":"lower(z, s...)\n\nEquivalent to translate([0,0,-z], s...).\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Overloaded-operators","page":"Transformations","title":"Overloaded operators","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The following operators are overloaded.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"vector + solid is a translation.\nreal * solid is a scaling.\ncomplex * 2dshape is a similitude.\nmatrix * solid is a linear transformation.\nvector * solid is a multiplication by a diagonal matrix.","category":"page"},{"location":"transformations/#Two-dimensional-drawing","page":"Transformations","title":"Two-dimensional drawing","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"offset","category":"page"},{"location":"transformations/#ConstructiveGeometry.offset","page":"Transformations","title":"ConstructiveGeometry.offset","text":"offset(r, solid...; kwargs...)\noffset(r; kwargs...) * solid\n\nOffsets by given radius. Positive radius is outside the shape, negative radius is inside.\n\nParameters for 2d shapes:     ends=:round|:square|:butt|:loop     join=:round|:miter|:square     miter_limit=2.0\n\nParameter for 3d solids:     npoints = 10 # how to subdivide segments\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = offset(10)*[square(100,50), square(50,100)];\npng(\"offset\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: an offset L-shape)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"opening","category":"page"},{"location":"transformations/#ConstructiveGeometry.opening","page":"Transformations","title":"ConstructiveGeometry.opening","text":"opening(r, shape...)\n\nMorphological opening: offset(-r) followed by offset(r). Removes small appendages and rounds convex corners.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = opening(10)*[square(100,50), square(50,100)];\npng(\"opening\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: the opening of the L-shape)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"closing","category":"page"},{"location":"transformations/#ConstructiveGeometry.closing","page":"Transformations","title":"ConstructiveGeometry.closing","text":"closing(r, shape...)\n\nMorphological closing: offset(r) followed by offset(-r). Removes small holes and rounds concave corners.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = closing(10)*[square(100,50), square(50,100)];\npng(\"closing\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: the closing of the L-shape)","category":"page"},{"location":"transformations/#Extrusion","page":"Transformations","title":"Extrusion","text":"","category":"section"},{"location":"transformations/#Linear-extrusion","page":"Transformations","title":"Linear extrusion","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"linear_extrude","category":"page"},{"location":"transformations/#ConstructiveGeometry.linear_extrude","page":"Transformations","title":"ConstructiveGeometry.linear_extrude","text":"linear_extrude(h, s...)\nlinear_extrude(h) * s...\n\nLinear extrusion to height h.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = linear_extrude(10)*[square(10,5), square(5,15)]\npng(\"linear_extrude\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: linear extrusion of a L-shape)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"rotate_extrude","category":"page"},{"location":"transformations/#ConstructiveGeometry.rotate_extrude","page":"Transformations","title":"ConstructiveGeometry.rotate_extrude","text":"rotate_extrude([angle = 360°], shape...)\nrotate_extrude([angle = 360°]) * shape\n\nSimilar to OpenSCAD's rotate_extrude primitive.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = rotate_extrude(245)*[square(10,5), square(5,15)]\npng(\"rotate_extrude\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: rotation extrusion of a L-shape)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"path_extrude","category":"page"},{"location":"transformations/#ConstructiveGeometry.path_extrude","page":"Transformations","title":"ConstructiveGeometry.path_extrude","text":"path_extrude(path, shape...)\n\nExtrudes the given shape by\n\nrotating the unit y-vector to the direction z, and \nmoving it so that the origin follows the path.\n\nFIXME: open-path extrusion is broken because ClipperLib currently does not support the etOpenSingle offset style.\n\n\n\n\n\n","category":"function"},{"location":"transformations/#Slicing","page":"Transformations","title":"Slicing","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"slice","category":"page"},{"location":"transformations/#ConstructiveGeometry.slice","page":"Transformations","title":"ConstructiveGeometry.slice","text":"slize(z, s...)\nslice(s...)\n\nComputes the (3d to 2d) intersection of a shape and the given horizontal plane (at z=0 if not precised).\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = slice()*setdiff(sphere(20),sphere(18));\npng(\"slice\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: slicing a hollow sphere)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"project","category":"page"},{"location":"transformations/#ConstructiveGeometry.project","page":"Transformations","title":"ConstructiveGeometry.project","text":"project(s...)\n\nComputes the (3d to 2d) projection of a shape on the horizontal plane.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = project()*setdiff(sphere(20),sphere(18));\npng(\"project\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: projecting a hollow sphere)","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"half_space","category":"page"},{"location":"transformations/#ConstructiveGeometry.half_space","page":"Transformations","title":"ConstructiveGeometry.half_space","text":"half_space(direction, origin, s...)\n\nKeeps only the part of 3d objects s lying in the halfspace with given direction and origin.\n\nTODO: more flexible syntax\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = half_space([0,0,-1],[0,0,0])*setdiff(sphere(20),sphere(18));\npng(\"halfspace\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: one half of a hollow sphere)","category":"page"},{"location":"transformations/#Decimation","page":"Transformations","title":"Decimation","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"decimate","category":"page"},{"location":"transformations/#ConstructiveGeometry.decimate","page":"Transformations","title":"ConstructiveGeometry.decimate","text":"decimate(n, surface...)\n\nDecimates a 3d surface to at most n triangular faces.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"loop_subdivide","category":"page"},{"location":"transformations/#ConstructiveGeometry.loop_subdivide","page":"Transformations","title":"ConstructiveGeometry.loop_subdivide","text":"loop_subdivide(n, shape...)\n\nApplies n iterations of loop subdivision to the solid. This does not preserve shape; instead, it tends to “round out” the solid.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"s = loop_subdivide(4)*cube(20);\npng(\"loop_subdivide\", s); # hide","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"(Image: example: loop subdivision of a cube)","category":"page"},{"location":"transformations/#Inserting-metadata","page":"Transformations","title":"Inserting metadata","text":"","category":"section"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as transform(parameters, s...) or as a product transform(parameters) * s.","category":"page"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"color","category":"page"},{"location":"transformations/#ConstructiveGeometry.color","page":"Transformations","title":"ConstructiveGeometry.color","text":"color(c::Colorant, s...)\ncolor(c::AbstractString, s...)\ncolor(c::AbstractString, α::Real, s...)\ncolor(c) * s...\n\nColors objects s... in the given color.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"set_parameters","category":"page"},{"location":"transformations/#ConstructiveGeometry.set_parameters","page":"Transformations","title":"ConstructiveGeometry.set_parameters","text":"set_parameters(;accuracy, precision, symmetry, ε, type) * solid...\n\nA transformation which passes down the specified parameter values to its child. Roughly similar to setting $fs and $fa in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"transformations/","page":"Transformations","title":"Transformations","text":"The set_parameters transformation allows attaching arbitrary metadata. This is on purpose (although there currently exists no easy way for an user to recover these metadata while meshing an object).","category":"page"},{"location":"primitives/#primitives","page":"Primitive solids","title":"Primitive solids","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"primitives/#Two-dimensional-objects","page":"Primitive solids","title":"Two-dimensional objects","text":"","category":"section"},{"location":"primitives/#Square","page":"Primitive solids","title":"Square","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"square","category":"page"},{"location":"primitives/#ConstructiveGeometry.square","page":"Primitive solids","title":"ConstructiveGeometry.square","text":"square(size; origin, center=false)\nsquare(width, height; origin, center=false)\n\nAn axis-parallel square or rectangle  with given size (scalar or vector of length 2).\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = square(20,15);\npng(\"square\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a square) square([20,15]) also works; square(20) produces a real square.","category":"page"},{"location":"primitives/#Circle","page":"Primitive solids","title":"Circle","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"circle","category":"page"},{"location":"primitives/#ConstructiveGeometry.circle","page":"Primitive solids","title":"ConstructiveGeometry.circle","text":"circle(r::Real)\n\nA circle with diameter r, centered at the origin.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = circle(20);\npng(\"circle\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a circle)","category":"page"},{"location":"primitives/#Stroke-path","page":"Primitive solids","title":"Stroke path","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"stroke","category":"page"},{"location":"primitives/#ConstructiveGeometry.stroke","page":"Primitive solids","title":"ConstructiveGeometry.stroke","text":"stroke(points, width; kwargs)\nends = :loop|:butt|:square|:round\njoin = :round|:square|:miter\nmiter_limit = 2.0\n\nDraws a path of given width.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = stroke([[0,0], [100,0],[100,100],[50,150],[0,100]],10);\ns1 = [120,0]+ stroke([[0,0], [100,0],[100,100],[50,150],[0,100]],10;ends=:loop,join=:square);\npng(\"stroke\", s ∪ s1); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a stroked path)","category":"page"},{"location":"primitives/#Polygon","page":"Primitive solids","title":"Polygon","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"polygon","category":"page"},{"location":"primitives/#ConstructiveGeometry.polygon","page":"Primitive solids","title":"ConstructiveGeometry.polygon","text":"polygon(path)\n\nFilled polygon delimitated by the given vertices.\n\nTODO: allow several paths and simplify crossing paths.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = polygon([[0,0], [100,0],[100,100],[50,150],[0,100]]);\npng(\"polygon\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a polygon)","category":"page"},{"location":"primitives/#Three-dimensional-objects","page":"Primitive solids","title":"Three-dimensional objects","text":"","category":"section"},{"location":"primitives/#Cube","page":"Primitive solids","title":"Cube","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cube","category":"page"},{"location":"primitives/#ConstructiveGeometry.cube","page":"Primitive solids","title":"ConstructiveGeometry.cube","text":"cube(size; origin, center=false)\ncube(size_x, size_y, size_z; origin, center=false)\n\nAn axis-parallel cube (or sett) with given size (scalar or vector of length 3).\n\nThe first vertex is at the origin and all vertices have positive coordinates. If center is true then the cube is centered.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cube(10,20,30);\npng(\"cube\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cube)","category":"page"},{"location":"primitives/#Cone","page":"Primitive solids","title":"Cone","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cone","category":"page"},{"location":"primitives/#ConstructiveGeometry.cone","page":"Primitive solids","title":"ConstructiveGeometry.cone","text":"cone(h, r)\n\nCircular right cone with basis centered at the origin, radius r, and height h.\n\ncone(apex, r)\n\nCircular, possibly oblique, cone with given apex point and radius r around the origin.\n\n\n\n\n\ncone(h, shape)\ncone(h)*shape\ncone(apex, shape)\ncone(apex)*shape\n\nCone with arbitrary base.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cone(50,10);\npng(\"cone\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cone)","category":"page"},{"location":"primitives/#Cylinder","page":"Primitive solids","title":"Cylinder","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"cylinder","category":"page"},{"location":"primitives/#ConstructiveGeometry.cylinder","page":"Primitive solids","title":"ConstructiveGeometry.cylinder","text":"cylinder(h, r1, r2 [, center=false])\ncylinder(h, (r1, r2) [, center=false])\ncylinder(h, r [, center=false])\n\nA cylinder (or cone frustum) with basis centered at the origin, lower radius r1, upper radius r2, and height h.\n\nWarning: cylinder(h,r) is interpreted as cylinder(h,r,r), not (h,r,0) as in OpenSCAD.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = cylinder(50,10);\npng(\"cylinder\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a cylinder)","category":"page"},{"location":"primitives/#Sphere","page":"Primitive solids","title":"Sphere","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"sphere","category":"page"},{"location":"primitives/#ConstructiveGeometry.sphere","page":"Primitive solids","title":"ConstructiveGeometry.sphere","text":"sphere(r::Real)\n\nA sphere with diameter r, centered at the origin.\n\n\n\n\n\n","category":"function"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = sphere(50);\npng(\"sphere\", s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a sphere)","category":"page"},{"location":"primitives/#Surface","page":"Primitive solids","title":"Surface","text":"","category":"section"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"surface(::Any,::Any)","category":"page"},{"location":"primitives/#MakieCore.surface-Tuple{Any, Any}","page":"Primitive solids","title":"MakieCore.surface","text":"surface(vertices, faces)\n\nProduces a surface with the given vertices. faces is a list of n-uples of indices into vertices. Only triangular faces are allowed now (non-triangular faces will be triangulated in a future release).\n\n\n\n\n\n","category":"method"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"s = surface([[0,0,0],[10,0,0],[10,10,0],[0,10,0],[5,5,5]],\n  [(1,2,5),(2,3,5),(3,4,5),(4,1,5),(2,1,3),(4,3,1)]);\npng(\"surface\",s); # hide","category":"page"},{"location":"primitives/","page":"Primitive solids","title":"Primitive solids","text":"(Image: example: a surface)","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/#Interface","page":"Meshing","title":"Interface","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"mesh(object, parameters...)","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The meshing of objects is governed by a few parameters:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"accuracy and precision determine the number of faces inserted in the mesh;\nsymmetry allows to impose a given rotational symmetry to circles;\ntype dictates the coordinate type of the returned mesh (e.g.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" `Float64` or `Rational{Int}`);","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"ε (experimental) is a value of thickness of planes, i.e. any point","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":" closer than `ε` from a plane is considered as belonging to the plane.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"To set values other than the defaults for an object, apply the set_parameters transform to that object:","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"set_parameters(accuracy=1)*\ncircle(2)","category":"page"},{"location":"meshing/#Accuracy-and-precision","page":"Meshing","title":"Accuracy and precision","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"accuracy is the maximum absolute deviation allowed when meshing an object.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is the maximum distance between the mesh and the ideal shape.  Its dimensionality is the same as basic length units for the object  (i.e. it will be understood as millimeters by most 3d slicers).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"precision is the maximum relative deviation allowed when meshing.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"This is a dimensionless number.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"When meshing an object, the minimum value will be used between those given by these two definitions. This means that precision gives an absolute maximum on the number of vertices for large objects, while accuracy governs the number of vertices for small objects.","category":"page"},{"location":"meshing/#Default-values","page":"Meshing","title":"Default values","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The default values are accuracy = 0.1 and precision = 1/200. The first value means that a circle will deviate by at most 0.1mm from the ideal circle, and  the latter value corresponds to the fact that large circles have 32 sides (see below).","category":"page"},{"location":"meshing/#Circles","page":"Meshing","title":"Circles","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"A circle of radius r is replaced by an inscribed n-gon. The deviation between the ideal circle and the n-gon is the sagitta of the circular segment with radius r and central angle 2πn; its value is hence s = r(1-cos(πn))  fracπ^2 r2 n^2.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"By definition, textttaccuracy = s while textttprecision = sr approx fracπ^22 n^2. This gives","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"n = min(π r(2textttaccuracy) π textttprecision))","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition, the number of sides is bounded below to always be at least 4. The number of sides thus increases as the square root of the radius, with an upper bound. With the default parameters, one has n  min(7r 32).","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The corresponding value for OpenSCAD is n = min(2πrtexttttextdollar fs360texttttextdollar fa); with the default values texttttextdollar fa=12 and texttttextdollar fs=2, this gives n  min(π r 30).","category":"page"},{"location":"meshing/#Spheres","page":"Meshing","title":"Spheres","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Spheres are rendered as Fibonacci spheres. This produces a more regular mesh than latitude-longitude grids.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"ConstructiveGeometry.sphere_nvertices","category":"page"},{"location":"meshing/#ConstructiveGeometry.sphere_nvertices","page":"Meshing","title":"ConstructiveGeometry.sphere_nvertices","text":"sphere_nvertices(r::Real, parameters::NamedTuple)\n\nReturns the number n of points on a sphere according to these parameters.\n\nThis produces n points on the sphere, hence 2n-4 triangular faces (genus 0). Average area of a triangular face is 4πr²/(2n-4)=2πr²/(n-2), hence square of edge length is d²≈ (8π/√3) r²/(n-2). (unit equilateral triangle area: A=√3d²/4, i.e. d²=(4/√3)A).\n\nSagitta is given by s/r = 1-√{1-d²/4r²} ≈ 1-(1-d²/8 r²) ≈ 1-(1-(π/√3)/(n-2)) ≈ (π/√3)/(n-2). Hence n ≈ 2 + (π/√3)/(precision).\n\n\n\n\n\n","category":"function"},{"location":"meshing/#Symmetry","page":"Meshing","title":"Symmetry","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"In addition to accuracy and precision, the symmetry parameter allows forcing the number of vertices of a circle to be a multiple of a defined value (by rounding up, if needed, to a multiple of symmetry).","category":"page"},{"location":"meshing/#Mesh-type-for-2d-objects","page":"Meshing","title":"Mesh type for 2d objects","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"2d objects are represented as the exclusive union (XOR) of simple-loop polygons.","category":"page"},{"location":"meshing/#Mesh-type-for-3d-objects","page":"Meshing","title":"Mesh type for 3d objects","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"3d objects are represented as a triangle mesh, in a way compatible with LibIGL's functions.","category":"page"},{"location":"#ConstructiveGeometry.jl-Documentation","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"This package provides tools for describing 3d objects in Julia. This includes mainly a syntax for building a CSG tree and functions for representing the objects. This syntax is inspired by OpenSCAD, but is actual Julia code:","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"# code for building the logo of this package\nusing ConstructiveGeometry\n\nhexagon = polygon([[cos(π*t/3),sin(π*t/3)] for t in 0:5])\nc1, c2, c3 = (\"#cb3c33\", \"#9558b2\", \"#389826\")\n\nbolt = linear_extrude(5)*(8*hexagon) ∪ cylinder(15,4)\n\nunion(\n  color(c1)*bolt,\n  [20,0,0]+color(c2)*bolt,\n  [10,17,0]+color(c3)*bolt)\n","category":"page"},{"location":"#Quick-start","page":"ConstructiveGeometry.jl Documentation","title":"Quick-start","text":"","category":"section"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"This package defines three kinds of abstract geometric objects (in either two or three dimensions):","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"primitive geometric objects, such as cubes, spheres, etc.;\ngeometric transformations acting on one object, such as (invertible) affine transformations, extrusions, projections, color-change, etc.;\nCSG operations combining several objects, such as boolean operations or Minkowski sum.","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"Any geometric object defined in this way may then be instantiated as an explicit mesh. The mesh can be visualized directly within Julia (using Makie) or exported as an STL (for 3d objects) or SVG (for 2d objects) file.","category":"page"},{"location":"","page":"ConstructiveGeometry.jl Documentation","title":"ConstructiveGeometry.jl Documentation","text":"```","category":"page"},{"location":"io/#Mesh-I/O","page":"Mesh I/O","title":"Mesh I/O","text":"","category":"section"},{"location":"io/#STL-output","page":"Mesh I/O","title":"STL output","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"ConstructiveGeometry.stl","category":"page"},{"location":"io/#ConstructiveGeometry.stl","page":"Mesh I/O","title":"ConstructiveGeometry.stl","text":"stl(file, object; options...)\n\nOutputs an STL description of object to the given file (string or IO). Optional kwargs are the same as for the mesh function or the set_parameters object.\n\n\n\n\n\n","category":"function"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"TODO: other file formats (.ply) ?","category":"page"},{"location":"io/#SVG-output","page":"Mesh I/O","title":"SVG output","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"ConstructiveGeometry.svg","category":"page"},{"location":"io/#ConstructiveGeometry.svg","page":"Mesh I/O","title":"ConstructiveGeometry.svg","text":"svg(file, shape)\n\nExports 2d shape as an SVG file.\n\n\n\n\n\n","category":"function"},{"location":"io/#STL-input","page":"Mesh I/O","title":"STL input","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"TODO.","category":"page"},{"location":"io/#OpenSCAD-output","page":"Mesh I/O","title":"OpenSCAD output","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"TODO.","category":"page"},{"location":"io/#OpenSCAD-to-Julia-conversion.","page":"Mesh I/O","title":"OpenSCAD to Julia conversion.","text":"","category":"section"},{"location":"io/","page":"Mesh I/O","title":"Mesh I/O","text":"Might be possible for a limited subset of OpenSCAD language. TODO.","category":"page"},{"location":"operations/#operations","page":"CSG operations","title":"CSG operations","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"CurrentModule = ConstructiveGeometry","category":"page"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"using ConstructiveGeometry\nusing Makie\nusing CairoMakie\npng(name, s) = save(name*\".png\", Makie.plot(s));","category":"page"},{"location":"operations/#Boolean-operations","page":"CSG operations","title":"Boolean operations","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"union(::AbstractGeometry,::AbstractGeometry)","category":"page"},{"location":"operations/#Base.union-Tuple{ConstructiveGeometry.AbstractGeometry, ConstructiveGeometry.AbstractGeometry}","page":"CSG operations","title":"Base.union","text":"union(a::AbstractGeometry{D}...)\n\nComputes the union of several solids. The dimensions must match.\n\n\n\n\n\n","category":"method"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"intersect(::AbstractGeometry{D},::AbstractGeometry{D}) where{D}","category":"page"},{"location":"operations/#Base.intersect-Union{Tuple{D}, Tuple{ConstructiveGeometry.AbstractGeometry{D}, ConstructiveGeometry.AbstractGeometry{D}}} where D","page":"CSG operations","title":"Base.intersect","text":"intersect(a::AbstractGeometry{D}...)\n\nComputes the intersection of several solids. Mismatched dimensions are allowed; 3d solids will be intersected with the (z=0) plane via the slice() operation.\n\n\n\n\n\n","category":"method"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"setdiff(::AbstractGeometry{D},::AbstractGeometry{D}) where{D}","category":"page"},{"location":"operations/#Base.setdiff-Union{Tuple{D}, Tuple{ConstructiveGeometry.AbstractGeometry{D}, ConstructiveGeometry.AbstractGeometry{D}}} where D","page":"CSG operations","title":"Base.setdiff","text":"setdiff(a::AbstractGeometry, b::AbstractGeometry)\n\nComputes the difference of two solids. The following dimensions are allowed: (2,2), (3,3), and (2,3) (in the last case, the 3d object will be intersected with the (z=0) plane via the slice() operation).\n\nsetdiff([a...], [b...])\n\nShorthand for setdiff(union(a...), union(b...)).\n\n\n\n\n\n","category":"method"},{"location":"operations/#Convex-hull","page":"CSG operations","title":"Convex hull","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"hull","category":"page"},{"location":"operations/#ConstructiveGeometry.hull","page":"CSG operations","title":"ConstructiveGeometry.hull","text":"hull(s::AbstractGeometry...)\nhull(s::AbstractGeometry{2} | StaticVector{2}...)\n\nRepresents the convex hull of given solids (and, possibly, points).\n\n\n\n\n\n","category":"function"},{"location":"operations/#Minkowski-sum","page":"CSG operations","title":"Minkowski sum","text":"","category":"section"},{"location":"operations/","page":"CSG operations","title":"CSG operations","text":"minkowski","category":"page"},{"location":"operations/#ConstructiveGeometry.minkowski","page":"CSG operations","title":"ConstructiveGeometry.minkowski","text":"minkowski(s::AbstractGeometry...)\n\nRepresents the Minkowski sum of given solids. This is currently implemented only for 2d objects.\n\n\n\n\n\n","category":"function"}]
}
