<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideal objects · ConstructiveGeometry.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ConstructiveGeometry.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ConstructiveGeometry.jl Documentation</a></li><li class="is-active"><a class="tocitem" href>Ideal objects</a><ul class="internal"><li><a class="tocitem" href="#Primitive-solids"><span>Primitive solids</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="../meshing/">Meshing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ideal objects</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideal objects</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/plut/ConstructiveGeometry.jl/blob/master/docs/src/ideal.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ideal-objects"><a class="docs-heading-anchor" href="#Ideal-objects">Ideal objects</a><a id="Ideal-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Ideal-objects" title="Permalink"></a></h1><h2 id="Primitive-solids"><a class="docs-heading-anchor" href="#Primitive-solids">Primitive solids</a><a id="Primitive-solids-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-solids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.Square" href="#ConstructiveGeometry.Square"><code>ConstructiveGeometry.Square</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Square(size; origin, center=false)</code></pre><p>An axis-parallel square or rectangle  with given <code>size</code> (scalar or vector of length 2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryBasics.Circle" href="#GeometryBasics.Circle"><code>GeometryBasics.Circle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Circle{T}</code></pre><p>An alias for a HyperSphere of dimension 2. (i.e. <code>HyperSphere{2, T}</code>)</p></div></section><section><div><pre><code class="language-none">Circle(radius)</code></pre><p>A circle. Discretization is done via the <code>accuracy</code> and <code>precision</code> parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.Cube" href="#ConstructiveGeometry.Cube"><code>ConstructiveGeometry.Cube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cube(size; origin, center=false)</code></pre><p>A cube or parallelepiped  with given <code>size</code> (scalar or vector of length 3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L360-L365">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ConstructiveGeometry.Cylinder</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GeometryBasics.Sphere" href="#GeometryBasics.Sphere"><code>GeometryBasics.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Sphere{T}</code></pre><p>An alias for a HyperSphere of dimension 3. (i.e. <code>HyperSphere{3, T}</code>)</p></div></section><section><div><pre><code class="language-none">Sphere(radius)</code></pre><p>A sphere. Discretization is done via the <code>accuracy</code> and <code>precision</code> parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L377-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.Polygon" href="#ConstructiveGeometry.Polygon"><code>ConstructiveGeometry.Polygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Polygon{T}
Polygon([point1, point2, ...])
Polygon(point1, point2, ...)</code></pre><p>A simple, closed polygon enclosed by the given vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L408-L414">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ConstructiveGeometry.Surface</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.NeutralSolid" href="#ConstructiveGeometry.NeutralSolid"><code>ConstructiveGeometry.NeutralSolid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NeutralSolid{D,T}</code></pre><p>A convenience type representing either an empty or full solid. This exists mostly to provide a neutral element for <code>union()</code> and <code>intersect()</code> operators, hence the name. In those cases, it is impossible to know in advance the dimension of the returned solid; hence, as an exception to the general rule, the <code>D</code> type parameter is either the symbol <code>:empty</code> or <code>:full</code>.</p><p>Since neutral objects are removed at compile-time from corresponding CSG operations, this should have no influence on the dimension of a top-level object.</p><p>The <code>T</code> type parameter is always <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L537-L553">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><p>All transformations accept two possible syntaxes:</p><pre><code class="language-julia">    transform(parameters, solid1, solid2, ...)
    transform(parameters) * solid1</code></pre><p>The second, multiplicative form allows easy chaining of transformations:</p><pre><code class="language-julia">    transform1(param1) * transform2(param2) * solid</code></pre><p>This form may also be applied to several solids by either wrapping them in a <code>union</code>, or equivalently, by applying it to a <code>Vector</code> of ConstructiveGeometry:</p><pre><code class="language-julia">    transform(parameters) * [ solid1, solid2, ... ]</code></pre><h3 id="Affine-transformations"><a class="docs-heading-anchor" href="#Affine-transformations">Affine transformations</a><a id="Affine-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-transformations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.mult_matrix" href="#ConstructiveGeometry.mult_matrix"><code>ConstructiveGeometry.mult_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mult_matrix(a, [center=c], solid...)
mult_matrix(a, b, solid...)
mult_matrix(a, b) * solid</code></pre><p>Represents the affine operation <code>x -&gt; a*x + b</code>.</p><p><strong>Extended help</strong></p><div class="admonition is-info"><header class="admonition-header">Types of `mult_matrix` parameters</header><div class="admonition-body"><p>The precise type of parameters <code>a</code> and <code>b</code> is not specified. Usually, <code>a</code> will be a matrix and <code>b</code> a vector, but this is left open on purpose; for instance, <code>a</code> can be a scalar (for a scaling) and <code>b</code> can be <code>Val(false)</code> for a linear operation. Any types so that <code>a * Vector + b</code> is defined will be accepted.</p><p>Conversion to a matrix will be done when converting to OpenSCAD format.</p></div></div><div class="admonition is-info"><header class="admonition-header">Matrix multiplication</header><div class="admonition-body"><p>Chained <code>mult_matrix</code> operations will be combined into a single operation when possible. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L942-L967">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.translate" href="#ConstructiveGeometry.translate"><code>ConstructiveGeometry.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">translate(v, s...)
translate(v) * s</code></pre><p>Translates solids <code>s...</code> by vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L984-L989">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.scale" href="#ConstructiveGeometry.scale"><code>ConstructiveGeometry.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale(a, s...; center=0)
scale(a; center=0) * s</code></pre><p>Scales solids <code>s</code> by factor <code>a</code>. If <code>center</code> is given then this will be the invariant point.</p><p><code>a</code> may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L991-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.rotate" href="#ConstructiveGeometry.rotate"><code>ConstructiveGeometry.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate(θ, {center=center}, {solid...})
rotate(θ, axis=axis, {center=center}, {solid...})</code></pre><p>Rotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L1019-L1025">source</a></section><section><div><pre><code class="language-none">rotate((θ,φ,ψ), {center=center}, {solid...})</code></pre><p>Rotation given by Euler angles (ZYX; same ordering as OpenSCAD).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L1027-L1031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.mirror" href="#ConstructiveGeometry.mirror"><code>ConstructiveGeometry.mirror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mirror(v, s...; center=0)
mirror(v; center=0) * s</code></pre><p>Reflection with axis given by the hyperplane normal to <code>v</code>. If <code>center</code> is given, then the affine hyperplane through this point will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L1003-L1010">source</a></section></article><p>TODO: <code>ConstructiveGeometry.project</code>, <code>ConstructiveGeometry.cut</code>.</p><h3 id="Extrusion"><a class="docs-heading-anchor" href="#Extrusion">Extrusion</a><a id="Extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Extrusion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.linear_extrude" href="#ConstructiveGeometry.linear_extrude"><code>ConstructiveGeometry.linear_extrude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linear_extrude(h, s...)
linear_extrude(h) * s...</code></pre><p>Linear extrusion to height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L819-L824">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ConstructiveGeometry.rotate_extrude</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.path_extrude" href="#ConstructiveGeometry.path_extrude"><code>ConstructiveGeometry.path_extrude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">	path_extrude(path, poly, options...)</code></pre><p>Extrudes the given polygon (a path of points forming a simple loop) along the given path. Both arguments are provided as a <code>Vector{SVector{2}}</code>.</p><p>Returns a <code>Surface</code> (defined by points and a triangulation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L3634-L3642">source</a></section></article><h3 id="Inserting-metadata"><a class="docs-heading-anchor" href="#Inserting-metadata">Inserting metadata</a><a id="Inserting-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-metadata" title="Permalink"></a></h3><p>A couple of transformations attach metadata to objects. These are defined using the same base types as affine transforms and can therefore be applied using the same syntax, i.e. either as <code>transform(parameters, s...)</code> or as a product <code>transform(parameters) * s</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.color" href="#ConstructiveGeometry.color"><code>ConstructiveGeometry.color</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">color(c::Colorant, s...)
color(c::AbstractString, s...)
color(c::AbstractString, α::Real, s...)
color(c) * s...</code></pre><p>Colors objects <code>s...</code> in the given color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L803-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.set_parameters" href="#ConstructiveGeometry.set_parameters"><code>ConstructiveGeometry.set_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameters(;accuracy=accuracy, precision=precision)</code></pre><p>A transformation which passes down the specified parameter values to its child. Roughly similar to setting <code>$fs</code> and <code>$fa</code> in OpenSCAD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L791-L796">source</a></section></article><h3 id="Defining-a-custom-transformation"><a class="docs-heading-anchor" href="#Defining-a-custom-transformation">Defining a custom transformation</a><a id="Defining-a-custom-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-custom-transformation" title="Permalink"></a></h3><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union(s, itrs...)
∪(s, itrs...)</code></pre><p>Construct the union of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia&gt; union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/abstractset.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>Construct the intersection of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/abstractset.jl#L97-L119">source</a></section><section><div><pre><code class="language-none">intersect(ss, others...)</code></pre><p>Each argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(<em>cn</em> log <em>n</em>), where <em>n</em> is the total number of items in all the arguments.</p></div></section><section><div><pre><code class="language-none">intersect(g, h)</code></pre><p>Return a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(intersect(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1</code></pre></div></section><section><div><pre><code class="language-none">intersect(P1::HRep, P2::HRep)</code></pre><p>Takes the intersection of <code>P1</code> and <code>P2</code> <span>$\{\, x : x \in P_1, x \in P_2 \,\}$</span>. It is very efficient between two H-representations or between two polyhedron for which the H-representation has already been computed. However, if <code>P1</code> (resp. <code>P2</code>) is a polyhedron for which the H-representation has not been computed yet, it will trigger a representation conversion which is costly. See the <a href="http://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node25.html">Polyhedral Computation FAQ</a> for a discussion on this operation.</p><p>The type of the result will be chosen closer to the type of <code>P1</code>. For instance, if <code>P1</code> is a polyhedron (resp. H-representation) and <code>P2</code> is a H-representation (resp. polyhedron), <code>intersect(P1, P2)</code> will be a polyhedron (resp. H-representation). If <code>P1</code> and <code>P2</code> are both polyhedra (resp. H-representation), the resulting polyhedron type (resp. H-representation type) will be computed according to the type of <code>P1</code>. The coefficient type however, will be promoted as required taking both the coefficient type of <code>P1</code> and <code>P2</code> into account.</p></div></section><section><div><pre><code class="language-none">intersect(v::VRepresentation{T}, h::HRepElement)</code></pre><p>Compute the intersection of <code>v</code> with an halfspace or hyperplane <code>h</code>. The method used by default is to keep the V-representation element of <code>v</code> that are in <code>h</code> and add new ones generated as the intersection between the hyperplane defining <code>h</code> and the segment between two adjacent V-representation elements of <code>v</code> that are in either sides of the hyperplane. See Lemma 3 of [FP96] for more detail on the method.</p><p>[FP96] Fukuda, K. and Prodon, A. <strong>Double description method revisited</strong> <em>Combinatorics and computer science</em>, <em>Springer</em>, <strong>1996</strong>, 91-111</p></div></section><section><div><pre><code class="language-none">intersect(s::AbstractGeometry...)
s1 ∩ s2</code></pre><p>Represents the intersection of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L650-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.difference" href="#ConstructiveGeometry.difference"><code>ConstructiveGeometry.difference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConstructiveGeometry.difference(s1, s2)</code></pre><p>Represents the difference <code>s1 ∖ s2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L688-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.hull" href="#ConstructiveGeometry.hull"><code>ConstructiveGeometry.hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hull(s::AbstractGeometry...)</code></pre><p>Represents the convex hull of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L665-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.minkowski" href="#ConstructiveGeometry.minkowski"><code>ConstructiveGeometry.minkowski</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minkowski(s::AbstractGeometry...)</code></pre><p>Represents the Minkowski sum of given solids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/cb8052ec94cb490b40c7d998f1f7a5ee1437baca/src/ConstructiveGeometry.jl#L658-L662">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« ConstructiveGeometry.jl Documentation</a><a class="docs-footer-nextpage" href="../meshing/">Meshing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 17 February 2021 13:15">Wednesday 17 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
