<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transformations · ConstructiveGeometry.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ConstructiveGeometry.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ConstructiveGeometry.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><code>ConstructiveGeometry.jl</code> Documentation</a></li><li><a class="tocitem" href="../primitives/">Primitive solids</a></li><li class="is-active"><a class="tocitem" href>Transformations</a><ul class="internal"><li><a class="tocitem" href="#Affine-transformations"><span>Affine transformations</span></a></li><li><a class="tocitem" href="#Overloaded-operators"><span>Overloaded operators</span></a></li><li><a class="tocitem" href="#Two-dimensional-drawing"><span>Two-dimensional drawing</span></a></li><li><a class="tocitem" href="#Extrusion"><span>Extrusion</span></a></li><li><a class="tocitem" href="#Decimation"><span>Decimation</span></a></li><li><a class="tocitem" href="#Coloring-objects"><span>Coloring objects</span></a></li><li><a class="tocitem" href="#Modifying-meshing-parameters"><span>Modifying meshing parameters</span></a></li></ul></li><li><a class="tocitem" href="../operations/">CSG operations</a></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../io/">Mesh I/O</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Transformations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transformations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/plut/ConstructiveGeometry.jl/blob/master/docs/src/transformations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transformations"><a class="docs-heading-anchor" href="#transformations">Transformations</a><a id="transformations-1"></a><a class="docs-heading-anchor-permalink" href="#transformations" title="Permalink"></a></h1><p>All single-object transformations accept two possible syntaxes:</p><pre><code class="language-julia">    transform(parameters, solid1, solid2, ...)
    transform(parameters) * solid1</code></pre><p>The second, multiplicative form allows easy chaining of transformations:</p><pre><code class="language-julia">    transform1(param1) * transform2(param2) * solid</code></pre><p>This form may also be applied to several solids by either wrapping them in a <code>union</code>, or equivalently, by applying it to a <code>Vector</code> of such objects:</p><pre><code class="language-julia">    transform(parameters) * [ solid1, solid2, ... ]</code></pre><h2 id="Affine-transformations"><a class="docs-heading-anchor" href="#Affine-transformations">Affine transformations</a><a id="Affine-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.mult_matrix" href="#ConstructiveGeometry.mult_matrix"><code>ConstructiveGeometry.mult_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mult_matrix(a, [center=c], solid...)
mult_matrix(a, b, solid...)
mult_matrix(a, b) * solid
a * solid + b # preferred form</code></pre><p>Represents the affine operation <code>x -&gt; a*x + b</code>.</p><p><strong>Extended help</strong></p><div class="admonition is-info"><header class="admonition-header">Types of `mult_matrix` parameters</header><div class="admonition-body"><p>The precise type of parameters <code>a</code> and <code>b</code> is not specified. Usually, <code>a</code> will be a matrix and <code>b</code> a vector, but this is left open on purpose; for instance, <code>a</code> can be a scalar (for a scaling). Any types so that <code>a * Vector + b</code> is defined will be accepted.</p><p>Conversion to a matrix will be done when meshing.</p></div></div><div class="admonition is-info"><header class="admonition-header">Matrix multiplication</header><div class="admonition-body"><p>Chained affine transformations are composed before applying to the objects. This saves time: multiple (3 × n) matrix multiplications are replaced by (3 × 3) multiplications, followed by a single (3 × n).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L739-L763">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = mult_matrix([1 0 0;0 1 0;0 .5 1])*cube(10);</code></pre><p><img src="../mult_matrix1.png" alt="a skewed cube"/></p><p>Only invertible affine transformations are supported. Transformations with a negative determinant reverse the object (either reverse the polygon loops, or reverse the triangular faces of meshes) to preserve orientation.</p><p>For non-invertible transformations, see <a href="../operations/#ConstructiveGeometry.project"><code>project</code></a>.</p><h3 id="embed"><a class="docs-heading-anchor" href="#embed">Three-dimensional embeddings of two-dimensional objects</a><a id="embed-1"></a><a class="docs-heading-anchor-permalink" href="#embed" title="Permalink"></a></h3><p>As an exception, it is allowed to apply a (2d -&gt; 3d) transformation to any three-dimensional object. The result of such a transformation is still two-dimensional (and will accordingly be rendered as a polygon), but the information about the embedding will be used when computing convex hull or Minkowski sum with a three-dimensional object.</p><pre><code class="language-julia-repl">julia&gt; s = hull([30,0,0]+[1 0 0;0 1 0;.5 0 0]*circle(20), [0,0,30]);</code></pre><p><img src="../embed_2d_3d.png" alt="convex hull of a non-canonically embedded circle and a point"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.translate" href="#ConstructiveGeometry.translate"><code>ConstructiveGeometry.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">translate(v, s...)
translate(v) * s
v + s</code></pre><p>Translates solids <code>s...</code> by vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L767-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.scale" href="#ConstructiveGeometry.scale"><code>ConstructiveGeometry.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale(a, s...; center=0)
scale(a; center=0) * s
a * s</code></pre><p>Scales solids <code>s</code> by factor <code>a</code>. If <code>center</code> is given then this will be the invariant point.</p><p><code>a</code> may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L790-L799">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = [1,1.5,2]*sphere(50);</code></pre><p><img src="../scaled_sphere.png" alt="a diagonally scaled sphere produces an ellipsoid"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.rotate" href="#ConstructiveGeometry.rotate"><code>ConstructiveGeometry.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate(θ, [center=center], [solid...])
rotate(θ, axis=axis, [center=center], [solid...])</code></pre><p>Rotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L816-L822">source</a></section><section><div><pre><code class="language-none">rotate((θ,φ,ψ), [center=center], [solid...])</code></pre><p>Rotation given by Euler angles (ZYX; same ordering as OpenSCAD).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L832-L836">source</a></section></article><p>Angles are in degrees by default. Angles in radians are supported through the use of <code>Unitful.rad</code>.</p><pre><code class="language-julia-repl">julia&gt; s = rotate(30)*square(20);</code></pre><p><img src="../rotate.png" alt="a rotated square"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.reflect" href="#ConstructiveGeometry.reflect"><code>ConstructiveGeometry.reflect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reflect(v, s...; center=0)
reflect(v; center=0) * s</code></pre><p>Reflection with axis given by the hyperplane normal to <code>v</code>. If <code>center</code> is given, then the affine hyperplane through this point will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L805-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.raise" href="#ConstructiveGeometry.raise"><code>ConstructiveGeometry.raise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">raise(z, s...)</code></pre><p>Equivalent to <code>translate([0,0,z], s...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L775-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.lower" href="#ConstructiveGeometry.lower"><code>ConstructiveGeometry.lower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lower(z, s...)</code></pre><p>Equivalent to <code>translate([0,0,-z], s...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L781-L785">source</a></section></article><h2 id="Overloaded-operators"><a class="docs-heading-anchor" href="#Overloaded-operators">Overloaded operators</a><a id="Overloaded-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-operators" title="Permalink"></a></h2><p>The following operators are overloaded.</p><ul><li><code>matrix * solid</code> is a linear transformation.</li><li><code>vector * solid</code> is a multiplication by a diagonal matrix.</li><li><code>vector + solid</code> is a translation.</li><li><code>real * solid</code> is a scaling.</li><li><code>complex * 2dshape</code> is a similitude.</li><li><code>color * solid</code> is a <code>color</code> operation.</li><li><code>color % solid</code> is a <code>highlight</code> operation.</li></ul><h2 id="Two-dimensional-drawing"><a class="docs-heading-anchor" href="#Two-dimensional-drawing">Two-dimensional drawing</a><a id="Two-dimensional-drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-drawing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.offset" href="#ConstructiveGeometry.offset"><code>ConstructiveGeometry.offset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">offset(r, solid...; kwargs...)
offset(r; kwargs...) * solid</code></pre><p>Offsets by given radius. Positive radius is outside the shape, negative radius is inside.</p><p>Parameters for 2d shapes:</p><pre><code class="language-none">ends=:round|:square|:butt|:loop
join=:round|:miter|:square
miter_limit=2.0</code></pre><p>Parameter for 3d solids:</p><pre><code class="language-none">maxgrid = 32 # upper bound on the number of cubes used in one direction</code></pre><div class="admonition is-warning"><header class="admonition-header">Complexity</header><div class="admonition-body"><p>Offset of a volume is a costly operation; it is realized using a marching cubes algorithm on a grid defined by <code>maxgrid</code>. 	Thus, its complexity is <strong>cubic</strong> in the parameter <code>maxgrid</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1328-L1350">source</a></section></article><p>The grid size used for offsetting is derived from the <code>atol</code> and <code>rtol</code> parameters, and upper bounded by the optional <code>maxgrid</code> parameter (if this is different from zero).</p><pre><code class="language-julia-repl">julia&gt; s1 = offset(10)*[square(100,50), square(50,100)];

julia&gt; s2 = offset(3)*cube(30);</code></pre><p><img src="../offset_L.png" alt="example: an offset L-shape"/> <img src="../offset_cube.png" alt="example: an offset cube"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.opening" href="#ConstructiveGeometry.opening"><code>ConstructiveGeometry.opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">opening(r, shape...; kwargs...)</code></pre><p><a href="https://en.wikipedia.org/wiki/Opening_(morphology)">Morphological opening</a>: offset(-r) followed by offset(r). Removes small appendages and rounds convex corners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1358-L1364">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = opening(10)*[square(100,50), square(50,100)];</code></pre><p><img src="../opening.png" alt="example: the opening of the L-shape"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.closing" href="#ConstructiveGeometry.closing"><code>ConstructiveGeometry.closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closing(r, shape...; kwargs...)</code></pre><p><a href="https://en.wikipedia.org/wiki/Closing_(morphology)">Morphological closing</a>: offset(r) followed by offset(-r). Removes small holes and rounds concave corners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1367-L1373">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = closing(10)*[square(100,50), square(50,100)];</code></pre><p><img src="../closing.png" alt="example: the closing of the L-shape"/></p><h2 id="Extrusion"><a class="docs-heading-anchor" href="#Extrusion">Extrusion</a><a id="Extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Extrusion" title="Permalink"></a></h2><h3 id="Linear-extrusion"><a class="docs-heading-anchor" href="#Linear-extrusion">Linear extrusion</a><a id="Linear-extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-extrusion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.linear_extrude" href="#ConstructiveGeometry.linear_extrude"><code>ConstructiveGeometry.linear_extrude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linear_extrude(h, s...; twist, scale)
linear_extrude(h) * s...</code></pre><p>Linear extrusion to height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1000-L1005">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s1 = linear_extrude(10)*[square(10,5), square(5,15)];


julia&gt; s2 = linear_extrude(20, twist=45, scale=.8)*[square(10,5), square(5,15)];</code></pre><p><img src="../linear_extrude.png" alt="example: linear extrusion of a L-shape"/> <img src="../linear_extrude_twist.png" alt="example: linear extrusion with twist"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.rotate_extrude" href="#ConstructiveGeometry.rotate_extrude"><code>ConstructiveGeometry.rotate_extrude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate_extrude([angle = 360°], shape...; slide=0)
rotate_extrude([angle = 360°]; [slide=0]) * shape</code></pre><p>Similar to OpenSCAD&#39;s <code>rotate_extrude</code> primitive.</p><p>The <code>slide</code> parameter is a displacement along the <code>z</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1203-L1210">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s1 = rotate_extrude(245)*[square(10,5), square(5,15)];


julia&gt; s2 = rotate_extrude(720, slide=30)*translate([10,0])*square(5);</code></pre><p><img src="../rotate_extrude.png" alt="example: rotation extrusion of a L-shape"/> <img src="../slide.png" alt="example: rotational extrusion with slide"/></p><p>The <code>cone</code> function may also be used as an operator to build a cone out of an arbitrary shape:</p><pre><code class="language-julia-repl">julia&gt; s = cone([1,2,3])*square(5);</code></pre><p><img src="../cone_pyramid.png" alt="example: using cone to build a pyramid"/></p><h3 id="Surface-sweep"><a class="docs-heading-anchor" href="#Surface-sweep">Surface sweep</a><a id="Surface-sweep-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-sweep" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.sweep" href="#ConstructiveGeometry.sweep"><code>ConstructiveGeometry.sweep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sweep(path, shape...)</code></pre><p>Extrudes the given <code>shape</code> by</p><ol><li>rotating perpendicular to the path (rotating the unit <em>y</em>-vector</li></ol><p>to the direction <em>z</em>), and </p><ol><li>sweeping it along the <code>path</code>, with the origin on the path.</li></ol><p>FIXME: open-path extrusion is broken because <code>ClipperLib</code> currently does not support the <code>etOpenSingle</code> offset style.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1260-L1270">source</a></section></article><p>A swept surface is similar to a (closed) path extrusion:</p><pre><code class="language-julia-repl">julia&gt; s = sweep(square(50))*circle(5);</code></pre><p><img src="../swept_circle.png" alt="example: a circle swept along a square"/></p><div class="admonition is-warning"><header class="admonition-header">Swept surfaces</header><div class="admonition-body"><p>A surface may only be swept along a closed loop (or the union of several closed loops) for now; this is a limitation of the <code>clipper</code> library, which <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/EndType.htm">does not support single-path extrusion</a> for now (and this is unlikely to change in the near future).</p></div></div><pre><code class="language-julia-repl">julia&gt; f(t) =([ cospi(t) -sinpi(t) 0;sinpi(t) cospi(t) 0;0 0 1],[0 0 10*t]);

julia&gt; s = sweep(f; nsteps=100,maxgrid=100)*cube(20);</code></pre><p><img src="../swept_cube.png" alt="example: a cube swept along a helix"/></p><h2 id="Decimation"><a class="docs-heading-anchor" href="#Decimation">Decimation</a><a id="Decimation-1"></a><a class="docs-heading-anchor-permalink" href="#Decimation" title="Permalink"></a></h2><p>These operations either reduce or increase the number of faces in a three-dimensional object.</p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.decimate" href="#ConstructiveGeometry.decimate"><code>ConstructiveGeometry.decimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decimate(n, surface...)</code></pre><p>Decimates a 3d surface to at most <code>n</code> triangular faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1386-L1390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.loop_subdivide" href="#ConstructiveGeometry.loop_subdivide"><code>ConstructiveGeometry.loop_subdivide</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loop_subdivide(n, shape...)</code></pre><p>Applies <code>n</code> iterations of loop subdivision to the solid. This does not preserve shape; instead, it tends to “round out” the solid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1401-L1407">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = loop_subdivide(4)*cube(20);</code></pre><p><img src="../loop_subdivide.png" alt="example: loop subdivision of a cube"/></p><h2 id="Coloring-objects"><a class="docs-heading-anchor" href="#Coloring-objects">Coloring objects</a><a id="Coloring-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Coloring-objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.color" href="#ConstructiveGeometry.color"><code>ConstructiveGeometry.color</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">color(c::Colorant, s...)
color(c::AbstractString, s...)
color(c::AbstractString, α::Real, s...)
color(c) * s...</code></pre><p>Colors objects <code>s...</code> in the given color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1443-L1450">source</a></section></article><pre><code class="language-julia-repl">julia&gt; green, red = parse.(ConstructiveGeometry.Colorant, (&quot;green&quot;, &quot;red&quot;))
(RGB{N0f8}(0.0,0.502,0.0), RGB{N0f8}(1.0,0.0,0.0))

julia&gt; s = union(green * cube(10), [10,0,0]+red*sphere(10));</code></pre><p><img src="../color.png" alt="example: union of a sphere and a cube"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.highlight" href="#ConstructiveGeometry.highlight"><code>ConstructiveGeometry.highlight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">highlight(c::Colorant, s)
highlight(c::AbstractString, s)
(c::Colorant) % s</code></pre><p>Marks an object as highlighted. This means that the base object will be displayed (in the specified color) at the same time as all results of operations built from this object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1469-L1477">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = intersect(green % cube(10), red % ([10,0,0]+sphere(10)));</code></pre><p><img src="../highlight.png" alt="example: intersection of a highlighted sphere and a highlighted cube"/></p><p>Highlighted parts of objects are shown only when the object is represented as an image via the <code>plot</code> method (either interactively with <code>GLMakie</code>, or as an image with <code>CairoMakie</code>). For SVG and STL output, all highlighted parts are ignored.</p><p>Highlighted objects are preserved only by CSG operations and (invertible) affine transformations. For other transformations:</p><ul><li>convex hull and Minkowski sum are generally increasing transformations, and would cover highlighted parts anyway;</li><li>projection, slicing and extrusion modify the dimension of object, making it impossible to preserve highlighted parts.</li></ul><h2 id="Modifying-meshing-parameters"><a class="docs-heading-anchor" href="#Modifying-meshing-parameters">Modifying meshing parameters</a><a id="Modifying-meshing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-meshing-parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.set_parameters" href="#ConstructiveGeometry.set_parameters"><code>ConstructiveGeometry.set_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameters(;atol, rtol, symmetry) * solid...</code></pre><p>A transformation which passes down the specified parameter values to its child. Roughly similar to setting <code>$fs</code> and <code>$fa</code> in OpenSCAD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/fbba66663af03845f407b177f33ea49e1a338577/src/ConstructiveGeometry.jl#L1423-L1428">source</a></section></article><p>The <code>set_parameters</code> transformation allows attaching arbitrary metadata. This is on purpose (although there currently exists no easy way for an user to recover these metadata while meshing an object).</p><p>The values for these parameters are explained in <a href="../meshing/#atol_rtol"><code>atol</code> and <code>rtol</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../primitives/">« Primitive solids</a><a class="docs-footer-nextpage" href="../operations/">CSG operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 18 November 2021 00:32">Thursday 18 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
