<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transformations ¬∑ ConstructiveGeometry.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ConstructiveGeometry.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ConstructiveGeometry.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><code>ConstructiveGeometry.jl</code> Documentation</a></li><li><a class="tocitem" href="../primitives/">Primitive solids</a></li><li class="is-active"><a class="tocitem" href>Transformations</a><ul class="internal"><li><a class="tocitem" href="#Affine-transformations"><span>Affine transformations</span></a></li><li><a class="tocitem" href="#Overloaded-operators"><span>Overloaded operators</span></a></li><li><a class="tocitem" href="#Two-dimensional-drawing"><span>Two-dimensional drawing</span></a></li><li><a class="tocitem" href="#Extrusion"><span>Extrusion</span></a></li><li><a class="tocitem" href="#User-defined-volume-deformations"><span>User-defined volume deformations</span></a></li><li><a class="tocitem" href="#Decimation"><span>Decimation</span></a></li><li><a class="tocitem" href="#Coloring-objects"><span>Coloring objects</span></a></li><li><a class="tocitem" href="#Modifying-meshing-parameters"><span>Modifying meshing parameters</span></a></li></ul></li><li><a class="tocitem" href="../operations/">CSG operations</a></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../io/">Mesh I/O</a></li><li><a class="tocitem" href="../extending/">Extending <code>ConstructiveGeometry</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Transformations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transformations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/plut/ConstructiveGeometry.jl/blob/master/docs/src/transformations.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transformations"><a class="docs-heading-anchor" href="#transformations">Transformations</a><a id="transformations-1"></a><a class="docs-heading-anchor-permalink" href="#transformations" title="Permalink"></a></h1><p>All single-object transformations accept two possible syntaxes:</p><pre><code class="language-julia">    transform(parameters, solid1, solid2, ...)
    transform(parameters) * solid1</code></pre><p>The second, multiplicative form allows easy chaining of transformations:</p><pre><code class="language-julia">    transform1(param1) * transform2(param2) * solid</code></pre><p>This form may also be applied to several solids by either wrapping them in a <code>union</code>, or equivalently, by applying it to a <code>Vector</code> of such objects:</p><pre><code class="language-julia">    transform(parameters) * [ solid1, solid2, ... ]</code></pre><h2 id="Affine-transformations"><a class="docs-heading-anchor" href="#Affine-transformations">Affine transformations</a><a id="Affine-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.mult_matrix" href="#ConstructiveGeometry.mult_matrix"><code>ConstructiveGeometry.mult_matrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mult_matrix(a, [center=c], solid...)
mult_matrix(a, b, solid...)
mult_matrix(a, b) * solid
a * solid + b # preferred form</code></pre><p>Represents the affine operation <code>x -&gt; a*x + b</code>.</p><p><strong>Extended help</strong></p><div class="admonition is-info"><header class="admonition-header">Types of `mult_matrix` parameters</header><div class="admonition-body"><p>The precise type of parameters <code>a</code> and <code>b</code> is not specified. Usually, <code>a</code> will be a matrix and <code>b</code> a vector, but this is left open on purpose; for instance, <code>a</code> can be a scalar (for a scaling). Any types so that <code>a * Vector + b</code> is defined will be accepted.</p><p>Conversion to a matrix will be done when meshing.</p></div></div><div class="admonition is-info"><header class="admonition-header">Matrix multiplication</header><div class="admonition-body"><p>Chained affine transformations are composed before applying to the objects. This saves time: multiple (3 √ó n) matrix multiplications are replaced by (3 √ó 3) multiplications, followed by a single (3 √ó n).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L875-L899">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = mult_matrix([1 0 0;0 1 0;0 .5 1])*cube(10);</code></pre><p><img src="../mult_matrix1.png" alt="a skewed cube"/></p><p>Only invertible affine transformations are supported. Transformations with a negative determinant reverse the object (either reverse the polygon loops, or reverse the triangular faces of meshes) to preserve orientation.</p><p>For non-invertible transformations, see <a href="../operations/#ConstructiveGeometry.project"><code>project</code></a>.</p><h3 id="embed"><a class="docs-heading-anchor" href="#embed">Three-dimensional embeddings of two-dimensional objects</a><a id="embed-1"></a><a class="docs-heading-anchor-permalink" href="#embed" title="Permalink"></a></h3><p>As an exception, it is allowed to apply a (2d -&gt; 3d) transformation to any two-dimensional object. The result of such a transformation is still two-dimensional (and will accordingly be rendered as a polygon), but the information about the embedding will be used when computing convex hull or Minkowski sum with a three-dimensional object.</p><pre><code class="language-julia-repl">julia&gt; s = hull([30,0,0]+[1 0 0;0 1 0;.5 0 0]*circle(20), [0,0,30]);</code></pre><p><img src="embed_2d_3d.png" alt="convex hull of a non-canonically embedded circle and a point"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.translate" href="#ConstructiveGeometry.translate"><code>ConstructiveGeometry.translate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">translate(v, s...)
translate(v) * s
v + s</code></pre><p>Translates object(s) <code>s...</code> by vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L903-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.scale" href="#ConstructiveGeometry.scale"><code>ConstructiveGeometry.scale</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale(a, s...; center=0)
scale(a; center=0) * s
a * s</code></pre><p>Scales solids <code>s</code> by factor <code>a</code>. If <code>center</code> is given then this will be the invariant point.</p><p><code>a</code> may also be a vector, in which case coordinates will be multiplied by the associated diagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L930-L939">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = [1,1.5,2]*sphere(50);</code></pre><p><img src="../scaled_sphere.png" alt="a diagonally scaled sphere produces an ellipsoid"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.rotate" href="#ConstructiveGeometry.rotate"><code>ConstructiveGeometry.rotate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate(Œ∏, [center=center], [solid...])</code></pre><p>Rotation around the Z-axis (in trigonometric direction, i.e. counter-clockwise).</p><pre><code class="language-none">rotate(Œ∏, axis=axis, [center=center], [solid...])</code></pre><p>Rotation around any axis, given by a vector directing this axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L956-L965">source</a></section><section><div><pre><code class="language-none">rotate((Œ∏,œÜ,œà), [center=center], [solid...])</code></pre><p>Rotation given by Euler angles (ZYX; same ordering as OpenSCAD).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L975-L979">source</a></section></article><p>Angles are in degrees by default. Angles in radians are supported through the use of <code>Unitful.rad</code>.</p><pre><code class="language-julia-repl">julia&gt; s = rotate(30)*square(20);</code></pre><p><img src="rotate.png" alt="a rotated square"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.reflect" href="#ConstructiveGeometry.reflect"><code>ConstructiveGeometry.reflect</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reflect(v, s...; center=0)
reflect(v; center=0) * s</code></pre><p>Reflection with axis given by the hyperplane normal to <code>v</code>. If <code>center</code> is given, then the affine hyperplane through this point will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L945-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.raise" href="#ConstructiveGeometry.raise"><code>ConstructiveGeometry.raise</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">raise(z, s...)</code></pre><p>For volumes: equivalent to <code>translate([0,0,z], s...)</code>. For shapes: equivalent to <code>translate([0,z], s...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L911-L916">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.lower" href="#ConstructiveGeometry.lower"><code>ConstructiveGeometry.lower</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lower(z, s...)</code></pre><p>For volumes: equivalent to <code>translate([0,0,-z], s...)</code>. For shapes: equivalent to <code>translate([0,z], s...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L920-L925">source</a></section></article><h2 id="Overloaded-operators"><a class="docs-heading-anchor" href="#Overloaded-operators">Overloaded operators</a><a id="Overloaded-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-operators" title="Permalink"></a></h2><p>The following operators are overloaded.</p><ul><li><code>matrix * solid</code> is a linear transformation.</li><li><code>vector * solid</code> is a multiplication by a diagonal matrix.</li><li><code>vector + solid</code> is a translation.</li><li><code>real * solid</code> is a scaling.</li><li><code>complex * 2dshape</code> is a similitude.</li><li><code>color * solid</code> is a <code>color</code> operation.</li><li><code>color % solid</code> is a <code>highlight</code> operation.</li></ul><h2 id="Two-dimensional-drawing"><a class="docs-heading-anchor" href="#Two-dimensional-drawing">Two-dimensional drawing</a><a id="Two-dimensional-drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-drawing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.offset" href="#ConstructiveGeometry.offset"><code>ConstructiveGeometry.offset</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">offset(r, solid...; kwargs...)
offset(r; kwargs...) * solid</code></pre><p>Offsets by given radius. Positive radius is outside the shape, negative radius is inside.</p><p>Parameters for 2d shapes:</p><pre><code class="language-none">ends=:round|:square|:butt|:loop
join=:round|:miter|:square
miter_limit=2.0</code></pre><p>Parameter for 3d solids:</p><pre><code class="language-none">maxgrid = 32 # upper bound on the number of cubes used in one direction</code></pre><div class="admonition is-warning"><header class="admonition-header">Complexity</header><div class="admonition-body"><p>Offset of a volume is a costly operation; it is realized using a marching cubes algorithm on a grid defined by <code>maxgrid</code>. 	Thus, its complexity is <strong>cubic</strong> in the parameter <code>maxgrid</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1601-L1623">source</a></section></article><p>The grid size used for offsetting is derived from the <code>atol</code> and <code>rtol</code> parameters, and upper bounded by the optional <code>maxgrid</code> parameter (if this is different from zero).</p><pre><code class="language-julia-repl">julia&gt; s1 = offset(10)*[square(100,50), square(50,100)];

julia&gt; s2 = offset(3)*cube(30);</code></pre><p><img src="offset_L.png" alt="example: an offset L-shape"/> <img src="../offset_cube.png" alt="example: an offset cube"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.opening" href="#ConstructiveGeometry.opening"><code>ConstructiveGeometry.opening</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">opening(r, shape...; kwargs...)</code></pre><p><a href="https://en.wikipedia.org/wiki/Opening_(morphology)">Morphological opening</a>: offset(-r) followed by offset(r). Removes small appendages and rounds convex corners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1631-L1637">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = opening(10)*[square(100,50), square(50,100)];</code></pre><p><img src="opening.png" alt="example: the opening of the L-shape"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.closing" href="#ConstructiveGeometry.closing"><code>ConstructiveGeometry.closing</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closing(r, shape...; kwargs...)</code></pre><p><a href="https://en.wikipedia.org/wiki/Closing_(morphology)">Morphological closing</a>: offset(r) followed by offset(-r). Removes small holes and rounds concave corners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1640-L1646">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = closing(10)*[square(100,50), square(50,100)];</code></pre><p><img src="closing.png" alt="example: the closing of the L-shape"/></p><h2 id="Extrusion"><a class="docs-heading-anchor" href="#Extrusion">Extrusion</a><a id="Extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Extrusion" title="Permalink"></a></h2><h3 id="Prism-(linear-extrusion)"><a class="docs-heading-anchor" href="#Prism-(linear-extrusion)">Prism (linear extrusion)</a><a id="Prism-(linear-extrusion)-1"></a><a class="docs-heading-anchor-permalink" href="#Prism-(linear-extrusion)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.prism" href="#ConstructiveGeometry.prism"><code>ConstructiveGeometry.prism</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prism(h, s...; twist, scale) # preferred form
prism(h; twist, scale) * s
linear_extrude(h, s...; twist, scale)
linear_extrude(h) * s...</code></pre><p>Build a prism (linear extrusion) of height <code>h</code> on the given base shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1146-L1153">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s1 = prism(10)*[square(10,5), square(5,15)];


julia&gt; s2 = prism(20, twist=45, scale=.8)*[square(10,5), square(5,15)];</code></pre><p><img src="prism.png" alt="example: linear extrusion of a L-shape"/> <img src="prism_twist.png" alt="example: linear extrusion with twist"/></p><h3 id="Revolution-(rotational-extrusion)"><a class="docs-heading-anchor" href="#Revolution-(rotational-extrusion)">Revolution (rotational extrusion)</a><a id="Revolution-(rotational-extrusion)-1"></a><a class="docs-heading-anchor-permalink" href="#Revolution-(rotational-extrusion)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.revolution" href="#ConstructiveGeometry.revolution"><code>ConstructiveGeometry.revolution</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">revolution([angle = 360¬∞], shape...; slide=0)
revolution([angle = 360¬∞]; [slide=0]) * shape
rotate_extrude([angle = 360¬∞], shape...; slide=0)
rotate_extrude([angle = 360¬∞]; [slide=0]) * shape</code></pre><p>Similar to OpenSCAD&#39;s <code>rotatre_extrude</code> primitive.</p><p>The <code>slide</code> parameter is a displacement along the <code>z</code> direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1355-L1364">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s1 = revolution(245)*[square(10,5), square(5,15)];


julia&gt; s2 = revolution(720, slide=30)*translate([10,0])*square(5);</code></pre><p><img src="revolution.png" alt="example: rotation extrusion of a L-shape"/> <img src="slide.png" alt="example: rotational extrusion with slide"/></p><p>The number of samples used for a revolution depends on the radius (i.e. the maximal abscisssa of a point on the shape) and the <code>atol</code> and <code>rtol</code> parameters, in the same way as the number of vertices of a circle does; see <a href="../meshing/#circle_vertices">Number of vertices of circles</a>.</p><h3 id="Conical-extrusion"><a class="docs-heading-anchor" href="#Conical-extrusion">Conical extrusion</a><a id="Conical-extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conical-extrusion" title="Permalink"></a></h3><p>The <code>cone</code> function may also be used as an operator to build a cone out of an arbitrary shape:</p><pre><code class="language-julia-repl">julia&gt; s = cone([1,2,3])*square(5);</code></pre><p><img src="cone_pyramid.png" alt="example: using cone to build a pyramid"/></p><h3 id="Surface-sweep"><a class="docs-heading-anchor" href="#Surface-sweep">Surface sweep</a><a id="Surface-sweep-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-sweep" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.sweep" href="#ConstructiveGeometry.sweep"><code>ConstructiveGeometry.sweep</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sweep(path, shape...)</code></pre><p>Extrudes the given <code>shape</code> by</p><ol><li>rotating perpendicular to the path (rotating the unit <em>y</em>-vector to the direction <em>z</em>), and </li><li>sweeping it along the <code>path</code>, with the origin on the path.</li></ol><hr/><pre><code class="language-none">sweep(transform, volume)</code></pre><p>Sweeps the given <code>volume</code> by applying the <code>transform</code>:</p><p>V&#39; = ‚ãÉ { f(t) ‚ãÖ V | t ‚àà [0,1] }</p><p><code>f</code> is a function mapping a real number in [0,1] to a pair (matrix, vector) defining an affine transform.</p><ul><li>nsteps:  upper bound on the number of steps for subdividing the [0,1] interval</li><li>gridsize: subdivision for marching cubes</li><li>isolevel: optional distance to add/subtract from swept volume</li></ul><p><strong>Extended help</strong></p><div class="admonition is-warning"><header class="admonition-header">Swept surfaces: limitations</header><div class="admonition-body"><p>The <code>sweep</code> feature currently has two main limitations:</p><ol><li>the trajectory may only contain closed loops (no open paths);</li><li>the extrusion of each profile vertex must preserve this topology.</li></ol><p>Both of these restrictions are due to the <code>clipper</code> library, which <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/EndType.htm">does not support single-side offset</a>. For an (<strong>experimental</strong>) remedy, see <code>path_extrude</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Complexity of swept volume</header><div class="admonition-body"><p>Volume sweep is a costly operation, implemented using a marching cubes algorithm on a grid defined by <code>gridsize</code>. 	Thus, its complexity is <strong>cubic</strong> in the parameter <code>gridsize</code>.</p></div></div><p>FIXME: unify <code>gridsize</code> and offset&#39;s <code>maxgrid</code> parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1415-L1455">source</a></section></article><p>A swept surface is similar to a (closed) path extrusion:</p><pre><code class="language-julia-repl">julia&gt; s = sweep(square(50))*circle(5);</code></pre><p><img src="../swept_circle.png" alt="example: a circle swept along a square"/></p><pre><code class="language-julia-repl">julia&gt; f(t) =([ cospi(t) -sinpi(t) 0;sinpi(t) cospi(t) 0;0 0 1],[0 0 10*t]);

julia&gt; s = sweep(f; nsteps=100,maxgrid=100)*cube(20);</code></pre><p><img src="../swept_cube.png" alt="example: a cube swept along a helix"/></p><h3 id="Path-extrusion"><a class="docs-heading-anchor" href="#Path-extrusion">Path extrusion</a><a id="Path-extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Path-extrusion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.path_extrude" href="#ConstructiveGeometry.path_extrude"><code>ConstructiveGeometry.path_extrude</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">path_extrude(trajectory)*profile</code></pre><p>Extrusion of the given <code>profile</code> along the trajectory.</p><div class="admonition is-info"><header class="admonition-header">Warning: path extrusion</header><div class="admonition-body"><p>This feature is still experimental. Success is not guaranteed. Also, API should not be considered stable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1480-L1490">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = path_extrude([[[0,0.],[3,0],[5,1]]])*(square(10)-([1,2]+square([6,5])));

[1;7m before splitting segments:[m
Input mesh is not PWN!</code></pre><p><img src="../path_extrude.png" alt="example: single-path extrusion of a shape"/></p><h2 id="User-defined-volume-deformations"><a class="docs-heading-anchor" href="#User-defined-volume-deformations">User-defined volume deformations</a><a id="User-defined-volume-deformations-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-volume-deformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.deform" href="#ConstructiveGeometry.deform"><code>ConstructiveGeometry.deform</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deform(f, s...; isvalid, distance2)</code></pre><p>Image of the volume <code>s</code> by the vertex-wise transformation <code>f</code> (as a function on <code>SVector{3}</code> points).</p><p>After applying the transformation, overlapping parts of the volume are cleaned by a self-union operation. <strong>It is however the user&#39;s responsibility to ensure that the image still forms a valid, positively-oriented mesh.</strong></p><p>Since <code>f</code> is (in principle) not a linear function, all edges longer than the the current <code>atol</code> meshing parameter will be split, using the <code>refine</code> transformation, before applying <code>f</code> to the vertices.</p><p>Optional parameters:</p><ul><li><code>isvalid</code>: a predicate which will be asserted on all points of the solid before applying the transformation;</li><li><code>distance2</code>: a function for evaluating which edges should be split. The default is to use the Euclidean distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1507-L1529">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s1 = deform(p-&gt;p/(3+p[1]))*cube(5);

julia&gt; s2 = deform(p-&gt;p/sqrt(1+p[1]))*cube(5);</code></pre><p><img src="../homographic_cube.png" alt="example: homographic image of a cube"/> <img src="../nonlinear_cube.png" alt="example: non-linear image of a cube"/></p><h3 id="Cylindrical-wrapping-(experimental)"><a class="docs-heading-anchor" href="#Cylindrical-wrapping-(experimental)">Cylindrical wrapping (experimental)</a><a id="Cylindrical-wrapping-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Cylindrical-wrapping-(experimental)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.wrap" href="#ConstructiveGeometry.wrap"><code>ConstructiveGeometry.wrap</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wrap(r, s...)</code></pre><p>Wraps the solid <code>s</code> around a cylinder with radius <code>r</code> by applying the coordinate transformation <span>$(x \cos(y/r), x \sin(y/r), z)$</span>. Long edges will be split so that their image resembles the correct spirals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1555-L1562">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = wrap(3)*cube(5);</code></pre><p><img src="../wrapped_cube.png" alt="example: a cube wrapped around a cylinder"/></p><h2 id="Decimation"><a class="docs-heading-anchor" href="#Decimation">Decimation</a><a id="Decimation-1"></a><a class="docs-heading-anchor-permalink" href="#Decimation" title="Permalink"></a></h2><p>These operations either reduce or increase the number of faces in a three-dimensional object.</p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.decimate" href="#ConstructiveGeometry.decimate"><code>ConstructiveGeometry.decimate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decimate(n, surface...)</code></pre><p>Decimates a 3d surface to at most <code>n</code> triangular faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1659-L1663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.loop_subdivide" href="#ConstructiveGeometry.loop_subdivide"><code>ConstructiveGeometry.loop_subdivide</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loop_subdivide(n, shape...)</code></pre><p>Applies <code>n</code> iterations of loop subdivision to the solid. This does not preserve shape; instead, it tends to ‚Äúround out‚Äù the solid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1674-L1680">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = loop_subdivide(4)*cube(20);</code></pre><p><img src="../loop_subdivide.png" alt="example: loop subdivision of a cube"/></p><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.refine" href="#ConstructiveGeometry.refine"><code>ConstructiveGeometry.refine</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">refine(maxlen, volume...)</code></pre><p>Splits all edges of <code>volume</code> repeatedly (preserving global geometry), until no edge is longer than <code>maxlen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1691-L1696">source</a></section></article><h2 id="Coloring-objects"><a class="docs-heading-anchor" href="#Coloring-objects">Coloring objects</a><a id="Coloring-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Coloring-objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.color" href="#ConstructiveGeometry.color"><code>ConstructiveGeometry.color</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">color(c::Colorant, s...)
color(c::AbstractString, s...)
color(c::AbstractString, Œ±::Real, s...)
color(c) * s...
colorant&quot;color&quot; * s...</code></pre><p>Colors objects <code>s...</code> in the given color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1734-L1742">source</a></section></article><pre><code class="language-julia-repl">julia&gt; green, red = colorant&quot;green&quot;, colorant&quot;red&quot;
(RGB{N0f8}(0.0,0.502,0.0), RGB{N0f8}(1.0,0.0,0.0))

julia&gt; s = union(green * cube(10), [10,0,0]+red*sphere(10));</code></pre><p><img src="../color.png" alt="example: union of a sphere and a cube"/></p><h3 id="Highlight"><a class="docs-heading-anchor" href="#Highlight">Highlight</a><a id="Highlight-1"></a><a class="docs-heading-anchor-permalink" href="#Highlight" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.highlight" href="#ConstructiveGeometry.highlight"><code>ConstructiveGeometry.highlight</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">highlight(c::Colorant, s)
highlight(c::AbstractString, s)
(c::Colorant) % s</code></pre><p>Marks an object as highlighted. This means that the base object will be displayed (in the specified color) at the same time as all results of operations built from this object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1774-L1782">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = intersect(green % cube(10), red % ([10,0,0]+sphere(10)));</code></pre><p><img src="../highlight.png" alt="example: intersection of a highlighted sphere and a highlighted cube"/></p><p>Highlighted parts of objects are shown only when the object is represented as an image via the <code>plot</code> method. For SVG and STL output, all highlighted parts are ignored.</p><p>Highlighted objects are preserved only by CSG operations and (invertible) affine transformations. For other transformations:</p><ul><li>convex hull and Minkowski sum are generally increasing transformations, and would cover highlighted parts anyway;</li><li>projection, slicing and extrusion modify the dimension of object, making it impossible to preserve highlighted parts.</li></ul><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.randomcolor" href="#ConstructiveGeometry.randomcolor"><code>ConstructiveGeometry.randomcolor</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomcolor(s...)</code></pre><p>Paints each triangle of <code>s</code> in a random color. Intended for debugging purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1756-L1760">source</a></section></article><pre><code class="language-julia-repl">julia&gt; s = randomcolor()*sphere(5);</code></pre><p><img src="../randomcolor.png" alt="example: sphere with random-colored triangular faces"/></p><h2 id="Modifying-meshing-parameters"><a class="docs-heading-anchor" href="#Modifying-meshing-parameters">Modifying meshing parameters</a><a id="Modifying-meshing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-meshing-parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstructiveGeometry.set_parameters" href="#ConstructiveGeometry.set_parameters"><code>ConstructiveGeometry.set_parameters</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameters(;atol, rtol, symmetry, icosphere) * solid...</code></pre><p>A transformation which passes down the specified parameter values to its child. Roughly similar to setting <code>$fs</code> and <code>$fa</code> in OpenSCAD.</p><p>See <code>meshing.md</code> for documentation about specific parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/plut/ConstructiveGeometry.jl/blob/d4ad95acd43f301f9acef3cf1b19168bd379e04e/src/ConstructiveGeometry.jl#L1712-L1719">source</a></section></article><p>The <code>set_parameters</code> transformation allows attaching arbitrary metadata. This is on purpose (although there currently exists no easy way for an user to recover these metadata while meshing an object).</p><p>The values for these parameters are explained in <a href="../meshing/#atol_rtol"><code>atol</code> and <code>rtol</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../primitives/">¬´ Primitive solids</a><a class="docs-footer-nextpage" href="../operations/">CSG operations ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 18 August 2022 17:15">Thursday 18 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
